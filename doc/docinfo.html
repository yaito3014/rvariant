<!--
  Copyright 2025 Nana Sakisaka
  Distributed under the Boost Software License, Version 1.0.
  https://www.boost.org/LICENSE_1_0.txt
-->
<link rel="license" href="{license-url}" title="{license-title}">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

body {
  font-size: 12.8px;
  font-family: DejaVuSans, 'DejaVu Sans', sans-serif;
  color: rgb(11, 11, 11);
}

h1, h2, h3, h4, h5, h6 {
  overflow: hidden;
  line-height: 1.3;
}

h1, h2, p, td.content, span.alt, summary {
  letter-spacing: inherit;
}

h1 > a {
  margin-left: 0.75rem;
}
h1 > a, h1 > a > span {
  display: inline-flex;
}

p strong, td.content strong, div.footnote strong {
  letter-spacing: inherit;
}

.quoteblock .attribution cite, .verseblock .attribution cite {
  letter-spacing: inherit;
}

p, td.content {
  font-size: inherit;
}

a {
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a, .underline {
  text-decoration-skip-ink: none;
}

a code {
  color: inherit;
}

:is(a code, code a) .hljs-comment {
  color: inherit;
}

dt {
  font-size: 1.3em;
}

:where(th, td):has(.good) {
  background-color: rgb(202, 255, 255);
}

:where(th, td):has(.bad) {
  background-color: rgb(255, 213, 213);
}

table.params tr th, table.params tr td {
  padding: .2em .25em;
}

code {
  font-family: 'DejaVu Sans Mono', monospace;
  max-width: 800px;
}

:not(pre):not([class^=L]) > code {
  background: rgb(239, 239, 241);
  border-radius: 0;
}

.hljs {
  background: unset;
}

pre code.hljs {
  padding: 0;
}

.listingblock:hover code[data-lang]::before {
  display: none;
}

:is(#fakeId, pre) code {
  position: relative;
}

:is(#fakeId, pre) code:has(.candidate) {
  padding-right: 4em;
}

code .candidate {
  display: inline-flex;
  position: absolute;
  right: 0;

  user-select: none;
  margin-right: 1em;
}

li p:has(+ .ulist) {
  margin-bottom: 0;
}

.slug {
  float: right;
  margin-left: .25em;
}

.slug a {
  text-decoration: none;
  font-size: 1rem;
  font-family: "Noto Serif", serif;
}

#toc .slug {
  display: none;
}

.candidate .hljs-comment {
  font-style: normal;
  font-weight: bold;
  color: #008000;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul {
  list-style-type: none;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  padding-left: 2rem;
  text-indent: -4.25rem;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  margin-bottom: 1em;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li :is(.paragraph, ul) {
  text-indent: 0;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li > p:has(+:is(.openblock, .ulist)),
:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li > .paragraph:has(+:is(.openblock, .ulist)) > p {
  margin-bottom: 0.25em;
}

.sect2 > p:has(+:is(.openblock, .ulist)),
.sect2 > .paragraph:has(+:is(.openblock, .ulist)) > p {
  margin-bottom: 1em;
}

:where(.sectionbody, .sect1, .sect2, .sect3, .sect4) > .ulist:not(.candidates) {
  margin-left: 1em;
}

.candidates .candidate {
  display: inline-block;
  width: 4rem;
  text-align: right;
  text-indent: 0;
  font-weight: bold;
  margin-left: 0;
}

.conum[data-value] {
  background: rgba(0, 0, 0, 0.6);
}

.see-below, .exposition-only {
  font-style: italic;
  font-weight: normal;
  color: rgb(129, 199, 129);
}

.small-note {
  font-size: 0.9em;
  opacity: 0.8;
}

.scroll-x {
  overflow-x: auto;
}

#toc.toc2 > ul {
  font-size: inherit;
}

#toc.toc2 #toctitle {
  font-size: 1.375em;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/cpp.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // https://github.com/highlightjs/highlight.js/issues/2889
  var mergeHTMLPlugin = (function () {
    'use strict';

    var originalStream;

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    /* plugin itself */

    /** @type {HLJSPlugin} */
    const mergeHTMLPlugin = {
      // preserve the original HTML token stream
      "before:highlightElement": ({ el }) => {
        originalStream = nodeStream(el);
      },
      // merge it afterwards with the highlighted token stream
      "after:highlightElement": ({ el, result, text }) => {
        if (!originalStream.length) return;

        const resultNode = document.createElement('div');
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
        el.innerHTML = result.value;
      }
    };

    /* Stream merging support functions */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
      return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
      /** @type Event[] */
      const result = [];
      (function _nodeStream(node, offset) {
        for (let child = node.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: 'start',
              offset: offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            // Prevent void elements from having an end tag that would actually
            // double them in the output. There are more void elements in HTML
            // but we list only those realistically expected in code display.
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: 'stop',
                offset: offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = '';
      const nodeStack = [];

      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return (original[0].offset < highlighted[0].offset) ? original : highlighted;
        }

        /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
        return highlighted[0].event === 'start' ? original : highlighted;
      }

      /**
       * @param {Node} node
       */
      function open(node) {
        /** @param {Attr} attr */
        function attributeString(attr) {
          return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        // @ts-ignore
        result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
      }

      /**
       * @param {Node} node
       */
      function close(node) {
        result += '</' + tag(node) + '>';
      }

      /**
       * @param {Event} event
       */
      function render(event) {
        (event.event === 'start' ? open : close)(event.node);
      }

      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
          nodeStack.reverse().forEach(close);
          do {
            render(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === 'start') {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }

    return mergeHTMLPlugin;
  }());

  hljs.addPlugin(mergeHTMLPlugin);
  hljs.configure({
    ignoreUnescapedHTML: true,
  });
  document.querySelectorAll('pre.highlight > code[data-lang]').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script>
