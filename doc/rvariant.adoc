= rvariant
Yaito Kakeyama; Nana Sakisaka
:doctype: book
:stylesheet: main.css
:source-highlighter: highlight.js
:highlightjs-theme: github
:icons: font
:sectanchors:
:idprefix:
:idseparator: -
:toc: left
:toc-title: rvariant
:toclevels: 2
:reproducible:

`rvariant` is a variant library that supports recursive types. It is API-compatible with `std::variant` and includes Boost-style interfaces that act as proxies to the standard-compatible API.

[preface]
= Introduction

=== Motivation
Since its introduction in 2004, `boost::variant` has been used for a wide range of type-safe union use cases.

Starting with {cpp}17, most of those can be replaced with `std::variant`, _except_ for *recursive types*. As a result, many users of generic frameworks that inherently require recursive variants--most notably Boost.Spirit--have continued using `boost::variant`, despite its significant impact on compile times.

The compile-time slowness of `boost::variant` stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with ``boost::variant``'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.

Until 2025, no one had managed to introduce a modern alternative into either Boost or the {cpp} standard. `rvariant` fills this gap with a new implementation that supports recursive types while remaining API-compatible with `std::variant`.


[#goals]
=== Project goals
1. Provide a modern, efficient, and battle-tested recursive variant library to enable developers to avoid using Boost.Variant in new applications.

2. Replace existing usages of Boost.Variant in established frameworks, especially Boost.Spirit.X3.

3. Gain implementation experience with a recursive variant library to explore potential directions for future standardization.


[#comparison]
=== Comparison of variant libraries

[.scroll-x]
--
[frame=ends,cols=",,,,"]
|===
|
h| `*temp_ns::rvariant*`
h| https://en.cppreference.com/w/cpp/utility/variant.html[`*std::variant*`]
h| https://www.boost.org/doc/libs/develop/doc/html/variant.html[`*Boost.Variant*`]
h| https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html[`*Boost.Variant2*`]

s| Required Version
| {cpp}20
| {cpp}17
| {cpp}11 +
icon:warning[] Mostly legacy code from 2003
| {cpp}11

s| Compilation Speed
| Fast
| Fast
| [.bad]*Very Slow*
| Fast

s| Can hold recursive types?
| [.good]*Yes*
| [.bad]*No*
| https://www.boost.org/doc/libs/develop/doc/html/boost/recursive_wrapper.html[[.good]*Yes*]
| [.bad]*No*

s| May be valueless?
| Yes
| https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html[Yes]
| https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty[No]
| https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_never_valueless[No]

s| Exception Safety
| Basic exception safety
| Basic exception safety
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution[(Temporary heap backup)]
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_strong_exception_safety[(Double storage)]

s| Allows flexible construction +
`V<A,B> = V<B,A>` +
`V<A,B,C> = V<A,B>`
| Yes
| [.bad]*No*
| Yes
| Yes
|===
--

NOTE: A variant class cannot determine its own size when it contains incomplete types. Therefore, recursive variants always require dynamic memory allocation.

= Reference

== Feature cheat sheet
This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.

[discrete]
=== Basic features

[,cpp,subs="+quotes,+macros,+attributes"]
----
using A = int;
using B = double;
struct C {};

using AB  = temp_ns::xref:#rvariant.rvariant[rvariant]<A, B>;
using BA  = temp_ns::rvariant<B, A>;
using ABC = temp_ns::rvariant<A, B, C>;

// xref:#rvariant.constructors[basic construction]
AB ab{123};

// recursive types
{
    struct BinaryExpr;
    using Expr = temp_ns::rvariant<A, B, C, temp_ns::xref:#rvariant.recursive[recursive_wrapper]<BinaryExpr>>;
    struct BinaryExpr { Expr lhs, rhs; };
}

A& a = temp_ns::xref:#accessors[get]<0>(ab);
A& a = temp_ns::get<A>(ab);
C& c = temp_ns::get<C>(ab); // throws https://en.cppreference.com/w/cpp/utility/variant/bad_variant_access.html[`std::bad_variant_access`]

A* a = temp_ns::xref:#accessors[get_if]<0>(&ab);
A* a = temp_ns::get_if<A>(&ab);
C* c = temp_ns::get_if<C>(&ab); // `nullptr`

// compatibility with boost; same effect as `get_if`
A* a = temp_ns::xref:#accessors[get]<0>(&ab);
A* a = temp_ns::get<A>(&ab);
C* c = temp_ns::get<C>(&ab); // `nullptr`

xref:#operators["ab == ab"];
xref:#operators[ab < ab];
xref:#operators[ab <=> ab]; // `requires (https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable[std::three_way_comparable]<Ts> && ...)`

temp_ns::xref:#accessors[visit](temp_ns::xref:#utility[overloaded] {
    [](A const& a) {},
    [](B const& b) {},
}, ab);
----

[discrete]
=== Advanced features

[,cpp,subs="+quotes,+macros,+attributes"]
----
// xref:#rvariant.constructors[flexible construction]
{
    AB ab = BA{};   // unordered construction
    ABC abc = AB{}; // subset construction
}

static_assert(temp_ns::xref:#trait-access[variant_size_v]<AB> == 2);
static_assert(std::same_as<temp_ns::xref:#trait-access[variant_alternative_t]<0, AB>, A>);
static_assert(temp_ns::xref:#trait-access[holds_alternative]<A>(ab));

static_assert(ab.index() != https://en.cppreference.com/w/cpp/utility/variant/variant_npos[std::variant_npos]);
static_assert(ab.which() == 0); // compatibility with boost; same effect as `.index()`

{
    using std::swap;
    AB tmp;
    xref:#accessors[swap](ab, tmp); // ADL
}

std::size_t _ = xref:#hashing[std::hash<AB>{ab}]();
std::size_t _ = xref:#hashing[hash_value(ab)]; // compatibility with boost

// xref:#io[I/O support]
{
    std::println("{}", AB{123});   // "123"
    std::cout << AB{123} << '\n';  // "123"

    // "type is A, value is 123" -- {cpp}26 reflection
    std::println("{:type is %t, value is %v}", AB{123}); // Note that %t prints `A`, not `int`

    std::println("{}", ABC{C{}});  // "C" -- {cpp}26 reflection
    std::cout << ABC{C{}} << '\n'; // "C" -- {cpp}26 reflection
}
----

[[rvariant.rvariant]]
== Class template `rvariant`

[,cpp,subs="+macros"]
----
#include <compare>
#include <utility> // for `std::in_place_type`, etc.
#include <variant> // for compatibility with `std::bad_variant_access`

namespace temp_ns {

template<class... Ts>
class rvariant
{
public:
    // xref:#rvariant.constructors[constructors]
    constexpr rvariant::rvariant() noexcept(/* see below */);
    constexpr rvariant::rvariant(rvariant const&);
    constexpr rvariant::rvariant(rvariant&&) noexcept(/* see below */);

    template<class T>
      constexpr rvariant(T&&) noexcept(/* see below */);

    template<class T, class... Args>
      constexpr explicit rvariant(std::in_place_type_t<T>, Args&&...);
    template<class T, class U, class... Args>
      constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U>, Args&&...);
    template<std::size_t I, class... Args>
      constexpr explicit rvariant(std::in_place_index_t<I>, Args&&...);
    template<std::size_t I, class U, class... Args>
      constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U>, Args&&...);

    /* extensions */
    template<class... Us>
      constexpr rvariant(rvariant<Us...> const& w);
    template<class... Us>
      constexpr rvariant(rvariant<Us...>&& w) noexcept(/* see below */);

    // xref:#rvariant.destructor[destructor]
    constexpr ~rvariant();

    // xref:#rvariant.assign[assignment]
    constexpr rvariant& operator=(rvariant const&);
    constexpr rvariant& operator=(rvariant&&) noexcept(/* see below */);

    template<class T> constexpr rvariant& operator=(T&&) noexcept(/* see below */);

    /* extensions */
    template<class... Us>
      constexpr rvariant& operator=(rvariant<Us...> const& w);
    template<class... Us>
      constexpr rvariant& operator=(rvariant<Us...>&& w) noexcept(/* see below */);

    // xref:#rvariant.mod[modifiers]
    template<class T, class... Args>
      constexpr T& emplace(Args&&...);
    template<class T, class U, class... Args>
      constexpr T& emplace(std::initializer_list<U>, Args&&...);
    template<std::size_t I, class... Args>
      constexpr variant_alternative_t<I, rvariant<Types...>>& emplace(Args&&...);
    template<std::size_t I, class U, class... Args>
      constexpr variant_alternative_t<I, rvariant<Types...>>&
        emplace(std::initializer_list<U>, Args&&...);

    // xref:#rvariant.status[value status]
    constexpr bool valueless_by_exception() const noexcept;
    constexpr std::size_t index() const noexcept;

    // ...
    // TODO
    // ...
};

} // temp_ns
----

[[rvariant.requirements]]
=== Requirements

Let *_rv_* be an instance of `rvariant<Ts\...>`.

* *_rv_* follows all type traits of `std::variant`, unless otherwise noted.
* All `Ts\...` must satisfy all constraints on `std::variant`, unless otherwise noted.

NOTE: See also: spec of https://eel.is/c++draft/variant[`std::variant`] and https://www.boost.org/doc/libs/develop/doc/html/variant/reference.html#variant.concepts[`boost::variant`]


[[rvariant.constructors]]
=== Constructors

[,cpp,subs="+macros"]
----
constexpr rvariant::rvariant() noexcept(/* see below */);pass:quotes[[.candidate\]#// 1#]
constexpr rvariant::rvariant(rvariant const&);pass:quotes[[.candidate\]#// 2#]
constexpr rvariant::rvariant(rvariant&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 3#]

template<class T>
constexpr rvariant(T&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 4#]

template<class T, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, Args&&...);pass:quotes[[.candidate\]#// 5#]

template<class T, class U, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U>, Args&&...);pass:quotes[[.candidate\]#// 6#]

template<std::size_t I, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, Args&&...);pass:quotes[[.candidate\]#// 7#]

template<std::size_t I, class U, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U>, Args&&...);pass:quotes[[.candidate\]#// 8#]

/* extensions */

template<class... Us>
    requires (!std::same_as<rvariant<Us...>, rvariant<Ts...>>)
constexpr rvariant(rvariant<Us...> const& w);pass:quotes[[.candidate\]#// 9#]

template<class... Us>
    requires (!std::same_as<rvariant<Us...>, rvariant<Ts...>>)
constexpr rvariant(rvariant<Us...>&& w) noexcept(/* see below */);pass:quotes[[.candidate\]#// 10#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.ctor
* [.candidate]#1-8)#
include::_spec-proxy.adoc[]

* [.candidate]#9)# Flexible copy constructor. If `w` does not hold a value, initializes the `rvariant` to not hold a value. Otherwise, initializes the `rvariant` to hold the corresponding alternative as `w` and direct-initializes the contained value with `_GET_<j>(w)`, where `j` is `w.index()` and `_GET_` is defined as per https://eel.is/c++draft/variant.get[[variant.get\]].
+
*_Remarks:_*

** This constructor is defined as deleted unless `xref:#rvariant.xo.flexibility[subset-like]<rvariant<Ts\...>, rvariant<Us\...>>` and `std::is_copy_constructible_v<U~_j_~>` is `true` for all _j_, where `U~_j_~` be the _j_^th^ type in `Us\...`.
** In case of duplicate alternative types, the corresponding index in `rvariant` shall be determined by the first occurrence of the same type in `Ts\...`.

* [.candidate]#10)# Flexible move constructor. If `w` does not hold a value, initializes the `rvariant` to not hold a value. Otherwise, initializes the `rvariant` to hold the corresponding alternative as `w` and direct-initializes the contained value with `_GET_<j>(std::move(w))`, where `j` is `w.index()` and `_GET_` is defined as per https://eel.is/c++draft/variant.get[[variant.get\]].
+
*_Remarks:_*

** This constructor is defined as deleted unless `xref:#rvariant.xo.flexibility[subset-like]<rvariant<Ts\...>, rvariant<Us\...>>`.
** The exception specification is equivalent to the logical `AND` of `std::is_nothrow_move_constructible_v<U~_j_~>` for all _j_, where `U~_j_~` be the _j_^th^ type in `Us\...`.
** In case of duplicate alternative types, the corresponding index in `rvariant` shall be determined by the first occurrence of the same type in `Ts\...`.
--

Exceptions ::
+
[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.ctor
* [.candidate]#1-8)#
include::_spec-proxy.adoc[]

* [.candidate]#9)# Throws any exception thrown by direct-initializing any type in `Us\...`.

* [.candidate]#10)# Throws any exception thrown by move-constructing any type in `Us\...`.
--


[[rvariant.destructor]]
=== Destructor

[,cpp,subs="+macros"]
----
constexpr ~rvariant();pass:quotes[[.candidate\]#// 1#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.dtor
* [.candidate]#1)#
include::_spec-proxy.adoc[]
--


[[rvariant.assign]]
=== Assignment

[,cpp,subs="+macros"]
----
constexpr rvariant& operator=(rvariant const&);pass:quotes[[.candidate\]#// 1#]
constexpr rvariant& operator=(rvariant&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 2#]

template<class T> constexpr rvariant& operator=(T&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 3#]

/* extensions */

template<class... Us>
    requires (!std::same_as<rvariant<Us...>, rvariant<Ts...>>)
constexpr rvariant& operator=(rvariant<Us...> const& w);pass:quotes[[.candidate\]#// 4#]

template<class... Us>
    requires (!std::same_as<rvariant<Us...>, rvariant<Ts...>>)
constexpr rvariant& operator=(rvariant<Us...>&& w) noexcept(/* see below */);pass:quotes[[.candidate\]#// 5#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.assign
* [.candidate]#1-3)#
include::_spec-proxy.adoc[]

* [.candidate]#4)# Flexible copy assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO

* [.candidate]#5)# Flexible move assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO
--


[[rvariant.mod]]
=== Modifiers

[,cpp,subs="+macros"]
----
template<class T, class... Args>
constexpr T& emplace(Args&&...);

template<class T, class U, class... Args>
constexpr T& emplace(std::initializer_list<U>, Args&&...);

template<std::size_t I, class... Args>
constexpr variant_alternative_t<I, rvariant<Types...>>&
    emplace(Args&&...);

template<std::size_t I, class U, class... Args>
constexpr variant_alternative_t<I, rvariant<Types...>>&
    emplace(std::initializer_list<U>, Args&&...);
----

:spec-url: https://eel.is/c++draft/variant.mod
include::_spec-proxy.adoc[]


[[rvariant.status]]
=== Value status

[,cpp,subs="+macros"]
----
constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;
----

:spec-url: https://eel.is/c++draft/variant.status
include::_spec-proxy.adoc[]


[[rvariant.swap]]
=== Swap

[,cpp,subs="+macros"]
----
constexpr void swap(rvariant&) noexcept(/* see below */);
----

:spec-url: https://eel.is/c++draft/variant.status
include::_spec-proxy.adoc[]


[[rvariant.deduping]]
== Pack manipulation and deduping

[WARNING]
Experimental feature proposal; need further consideration

[,cpp,subs="+macros"]
----
namespace temp_ns {

template<template<class...> class TT, class A, class B>
struct pack_union;pass:quotes[[.candidate\]#// 1#]

template<template<class...> class TT, class A, class B>
struct pack_union_t = typename pack_union<TT, A, B>::type;

template<template<class...> class TT, class A, class B>
struct compact_alternative;pass:quotes[[.candidate\]#// 2#]

template<template<class...> class TT, class A, class B>
using compact_alternative_t = typename compact_alternative<TT, A, B>::type;

} // temp_ns
----

[.candidates]
--
* [.candidate]#1)# Let `As` denote the pack of template parameters of `A` if xref:#rvariant.xo.core[`_specialization-of<A, TT>_`], otherwise let `As` denote a pack of single type `A`. Let `Bs` denote likewise. `pack_union` defines the member type `::type` as `TT<Ts\...>`, where `Ts\...` is the union of `As\...` and `Bs\...`. The order of types shall be preserved.

* [.candidate]#2)# Let `Ts` denote an imaginary pack of types where `TT<Ts\...>` is the same type as `pack_union_t<TT, A, B>`. `compact_alternative` defines the member type `::type` as the first type in `Ts\...` if `sizeof\...(Ts) == 1`; otherwise, it is defined as `TT<Ts\...>`.
--

[NOTE]
.Notes on single-type variant
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be _unwrapped_ using `compact_alternative`. This is useful for resolving issues such as https://github.com/boostorg/spirit/issues/610[boostorg/spirit#610].


[[rvariant.recursive]]
== Class template `recursive_wrapper`

[,cpp,subs="+quotes"]
----
#include <compare>

namespace temp_ns {

template<class T>
class recursive_wrapper
{
public:

private:
};

} // temp_ns
----

=== Constructors
...


[[rvariant.xo]]
== Exposition-only utilities
This section demonstrates internal features used in the implementation.


[[rvariant.xo.flexibility]]
=== Flexibility traits

[,cpp,subs="+macros"]
----
template<class V, class W>
struct pass:quotes[_subset_like_] : std::false_type {}; // exposition-only

template<class... Ts, class... Us>
struct pass:quotes[_subset_like_]<rvariant<Ts...>, rvariant<Us...>> : std::true_type {}; // exposition-onlypass:quotes[[.candidate\]#// 1#]

template<class V, class W>
constexpr bool pass:quotes[_subset-like_] = pass:quotes[_subset_like_]::value; // exposition-only
----

[.candidates]
--
* [.candidate]#1)# *_Constraints:_* For every type `U` in `Us\...`, there exists at least one type `T` in `Ts\...` such that `U` is the same type as `T`.
--


[[rvariant.xo.core]]
=== Core type traits

[,cpp,subs="+macros"]
----
template<class T, template<class...> class TT>
struct pass:quotes[_ttp-specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 1#]

template<class T, template<auto...> class TT>
struct pass:quotes[_nttp-specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 2#]

template<class T, pass:quotes[_any-ttp_]>
struct pass:quotes[_specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 3#]
----

[.candidates]
--
* [.candidate]#1-2)# Inherits `std::true_type` if and only if `T` is a specialization of `TT`; otherwise, `std::false_type`.

* [.candidate]#3)# If `_any-ttp_` is a template template parameter that consists of NTTP, equivalent to `_nttp-specialization-of_`; otherwise, equivalent to `_ttp-specialization-of_`.
+
NOTE: `_specialization-of_` is currently unimplementable due to lack of language feature; it requires C++26 reflection for a straightforward resolution. For now, it can be worked around by a compound `requires` expression.
--



= Additional information

== Benchmark

Non-recursive / Recursive

GCC / Clang / MSVC
