= rvariant
Yaito Kakeyama; Nana Sakisaka
:doctype: book
:stylesheet: main.css
:source-highlighter: highlight.js
:highlightjs-theme: github
:icons: font
:sectanchors:
:idprefix:
:idseparator: -
:toc: left
:toc-title: rvariant
:toclevels: 2
:reproducible:

`rvariant` is a variant library that supports recursive types. It is API-compatible with `std::variant` and includes Boost-style interfaces that act as proxies to the standard-compatible API.

[preface]
= Introduction

=== Motivation
Since its introduction in 2004, `boost::variant` has been used for a wide range of type-safe union use cases.

Starting with {cpp}17, most of those can be replaced with `std::variant`, _except_ for *recursive types*. As a result, many users of generic frameworks that inherently require recursive variants--most notably Boost.Spirit--have continued using `boost::variant`, despite its significant impact on compile times.

The compile-time slowness of `boost::variant` stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with ``boost::variant``'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.

Until 2025, no one had managed to introduce a modern alternative into either Boost or the {cpp} standard. `rvariant` fills this gap with a new implementation that supports recursive types while remaining API-compatible with `std::variant`.


[#goals]
=== Project goals
1. Provide a modern, efficient, and battle-tested recursive variant library to enable developers to avoid using Boost.Variant in new applications.

2. Replace existing usages of Boost.Variant in established frameworks, especially Boost.Spirit.X3.

3. Gain implementation experience with a recursive variant library to explore potential directions for future standardization.


[#comparison]
=== Comparison of variant libraries

[.scroll-x]
--
[frame=ends,cols=",,,,"]
|===
|
h| `*temp_ns::rvariant*`
h| https://en.cppreference.com/w/cpp/utility/variant.html[`*std::variant*`]
h| https://www.boost.org/doc/libs/develop/doc/html/variant.html[`*Boost.Variant*`]
h| https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html[`*Boost.Variant2*`]

s| Required Version
| {cpp}20
| {cpp}17
| {cpp}11 +
icon:warning[] Mostly legacy code from 2003
| {cpp}11

s| Compilation Speed
| Fast
| Fast
| [.bad]*Very Slow*
| Fast

s| Can hold recursive types?
| [.good]*Yes*
| [.bad]*No*
| https://www.boost.org/doc/libs/develop/doc/html/boost/recursive_wrapper.html[[.good]*Yes*]
| [.bad]*No*

s| May be valueless?
| Yes
| https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html[Yes]
| https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty[No]
| https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_never_valueless[No]

s| Exception Safety
| Basic exception safety
| Basic exception safety
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution[(Temporary heap backup)]
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_strong_exception_safety[(Double storage)]

s| Allows flexible construction +
`V<A,B> = V<B,A>` +
`V<A,B,C> = V<A,B>`
| Yes
| [.bad]*No*
| Yes
| Yes
|===
--

NOTE: A variant class cannot determine its own size when it contains incomplete types. Therefore, recursive variants always require dynamic memory allocation.

= Reference

== Feature cheat sheet
This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.

[discrete]
=== Basic features

[,cpp,subs="+quotes,+macros,+attributes"]
----
using A = int;
using B = double;
struct C {};

using AB  = temp_ns::xref:#rvariant.rvariant[rvariant]<A, B>;
using BA  = temp_ns::rvariant<B, A>;
using ABC = temp_ns::rvariant<A, B, C>;

// xref:#rvariant.constructors[constructor]
AB ab{42};

{
    AB local_ab{};
} // xref:#rvariant.destructor[destructor]

abxref:#rvariant.mod[.emplace<int>(123)];
abxref:#rvariant.mod[.emplace<0>(123)];

// xref:#rvariant.assign[assignment]
ab = AB{123};

// recursive types
{
    struct BinaryExpr;
    using Expr = temp_ns::rvariant<A, B, C, temp_ns::xref:#rvariant.recursive[recursive_wrapper]<BinaryExpr>>;
    struct BinaryExpr { Expr lhs, rhs; };
}

A& a = temp_ns::xref:#rvariant.syn[get]<0>(ab);
A& a = temp_ns::get<A>(ab);
C& c = temp_ns::get<C>(ab);     // throws https://en.cppreference.com/w/cpp/utility/variant/bad_variant_access.html[`std::bad_variant_access`]

A* a = temp_ns::xref:#rvariant.syn[get_if]<0>(&ab);
A* a = temp_ns::get_if<A>(&ab);
C* c = temp_ns::get_if<C>(&ab); // `nullptr`

// compatibility with boost; same effect as `get_if`
A* a = temp_ns::xref:#rvariant.syn[get]<0>(&ab);
A* a = temp_ns::get<A>(&ab);
C* c = temp_ns::get<C>(&ab);    // `nullptr`

xref:#rvariant.syn["ab == ab"];
xref:#rvariant.syn[ab < ab];
xref:#rvariant.syn[ab <=> ab]; // `requires (https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable[std::three_way_comparable]<Ts> && ...)`

auto visitor = temp_ns::xref:#rvariant.utility-todo[overloaded] {
    [](A const& a) {},
    [](B const& b) {},
};

abxref:#rvariant.visit[.visit(visitor)];           // member visit
temp_ns::xref:#rvariant.syn[visit](visitor, ab); // function visit
----


[discrete]
=== Advanced features

[,cpp,subs="+quotes,+macros,+attributes"]
----
{
    // xref:#rvariant.constructors[flexible construction]
    AB ab{BA{}};   // unordered construction
    ABC abc{AB{}}; // subset construction

    // xref:#rvariant.assign[flexible assignment]
    ab = BA{};     // unordered assignment
    abc = AB{};    // subset assignment
}

static_assert(temp_ns::xref:#rvariant.syn[variant_size_v]<AB> == 2);
static_assert(std::same_as<temp_ns::xref:#rvariant.syn[variant_alternative_t]<0, AB>, A>);
static_assert(temp_ns::xref:#rvariant.syn[holds_alternative]<A>(ab));

static_assert(abxref:#rvariant.status[.index()] != https://en.cppreference.com/w/cpp/utility/variant/variant_npos[std::variant_npos]);
static_assert(!abxref:#rvariant.status[.valueless_by_exception()]);

{
    AB tmp;
    abxref:#rvariant.swap[.swap(tmp)];
}
{
    using std::swap;
    AB tmp;
    xref:#rvariant.syn[swap](ab, tmp); // ADL
}

std::size_t _ = xref:#rvariant.syn[std::hash<AB>{ab}]();
std::size_t _ = xref:#rvariant.syn[hash_value(ab)]; // compatibility with boost

// xref:#rvariant.io[I/O support]
{
    std::println("{}", AB{123});   // "123"
    std::cout << AB{123} << '\n';  // "123"

    // "type is A, value is 123" -- {cpp}26 reflection
    std::println("{:type is %t, value is %v}", AB{123}); // Note that %t prints `A`, not `int`

    std::println("{}", ABC{C{}});  // "C" -- {cpp}26 reflection
    std::cout << ABC{C{}} << '\n'; // "C" -- {cpp}26 reflection
}
----


[[rvariant.syn]]
== Header <temp_ns/rvariant.hpp> synopsis

[,cpp,subs="+macros"]
----
#include <compare>
#include <utility> // for `std::in_place_type`, etc.
#include <variant> // for compatibility with `std::bad_variant_access`

namespace temp_ns {

// xref:#rvariant.rvariant[class template pass:quotes[`rvariant`]]
template<class... Ts>
class rvariant;

/* all features commented below defined as per https://eel.is/c+\+draft/variant[[variant\]] */
    // variant_size, variant_size_v
    // variant_alternative, variant_alternative_v
    // get
    // get_if

    // operator==
    // operator!=
    // operator<
    // operator>
    // operator<=
    // operator>=
    // operator<=>

    // visit
    // swap

https://eel.is/c++draft/variant.syn[/* not defined; use the pass:quotes[`std::`] versions instead */]
    // variant_npos
    // monostate and monostate-related functionalities
    // bad_variant_access

/* extension */

template<std::size_t I, class... Ts>
  constexpr /* equivalent to standard */
    get(rvariant<Ts...>*) noexcept;       // delegates to `get_if`

template<std::size_t I, class... Ts>
  constexpr /* equivalent to standard */
    get(rvariant<Ts...> const*) noexcept; // delegates to `get_if`

template<class T, class... Ts>
  constexpr /* equivalent to standard */
    get(rvariant<Ts...>*) noexcept;       // delegates to `get_if`

template<class T, class... Ts>
  constexpr /* equivalent to standard */
    get(rvariant<Ts...> const*) noexcept; // delegates to `get_if`

// ...
// TODO: I/O
// ...

template<class... Ts>
/* constexpr */ std::size_t hash_value(rvariant<Ts...> const& v);

} // temp_ns
----

[,cpp,subs="+macros"]
----
namespace std {

template<class... Ts> struct hash<::temp_ns::rvariant<Ts...>>;

} // std
----


[[rvariant.rvariant]]
== Class template `rvariant`

[,cpp,subs="+macros"]
----
namespace temp_ns {

template<class... Ts>
class rvariant
{
public:
  // xref:#rvariant.constructors[constructors]
  constexpr rvariant::rvariant() noexcept(/* see below */);
  constexpr rvariant::rvariant(rvariant const&);
  constexpr rvariant::rvariant(rvariant&&) noexcept(/* see below */);

  template<class T>
    constexpr rvariant(T&&) noexcept(/* see below */);

  template<class T, class... Args>
    constexpr explicit rvariant(std::in_place_type_t<T>, Args&&...);
  template<class T, class U, class... Args>
    constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U>, Args&&...);
  template<std::size_t I, class... Args>
    constexpr explicit rvariant(std::in_place_index_t<I>, Args&&...);
  template<std::size_t I, class U, class... Args>
    constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U>, Args&&...);

  // xref:#rvariant.constructors[flexible constructors]
  template<class... Us>
    constexpr rvariant(rvariant<Us...> const& w);
  template<class... Us>
    constexpr rvariant(rvariant<Us...>&& w) noexcept(/* see below */);

  // xref:#rvariant.destructor[destructor]
  constexpr ~rvariant();

  // xref:#rvariant.assign[assignment]
  constexpr rvariant& operator=(rvariant const&);
  constexpr rvariant& operator=(rvariant&&) noexcept(/* see below */);

  template<class T> constexpr rvariant& operator=(T&&) noexcept(/* see below */);

  // xref:#rvariant.assign[flexible assignment]
  template<class... Us>
    constexpr rvariant& operator=(rvariant<Us...> const& w);
  template<class... Us>
    constexpr rvariant& operator=(rvariant<Us...>&& w) noexcept(/* see below */);

  // xref:#rvariant.mod[modifiers]
  template<class T, class... Args>
    constexpr T& emplace(Args&&...);
  template<class T, class U, class... Args>
    constexpr T& emplace(std::initializer_list<U>, Args&&...);
  template<std::size_t I, class... Args>
    constexpr variant_alternative_t<I, rvariant<Types...>>& emplace(Args&&...);
  template<std::size_t I, class U, class... Args>
    constexpr variant_alternative_t<I, rvariant<Types...>>&
      emplace(std::initializer_list<U>, Args&&...);

  // xref:#rvariant.status[value status]
  constexpr bool valueless_by_exception() const noexcept;
  constexpr std::size_t index() const noexcept;

  // xref:#rvariant.subset[subset]
  template<class... Us>
    constexpr rvariant<Us...> subset() const& noexcept(/* see below */);
  template<class... Us>
    constexpr rvariant<Us...> subset() && noexcept(/* see below */);

  // xref:#rvariant.swap[swap]
  constexpr void swap(rvariant&) noexcept(/* see below */);

  // xref:#rvariant.visit[visitation]
  template<class Self, class Visitor>
    constexpr decltype(auto) visit(this Self&&, Visitor&&);
  template<class R, class Self, class Visitor>
    constexpr R visit(this Self&&, Visitor&&);
};

} // temp_ns
----


[[rvariant.general]]
=== General

* `rvariant<Ts\...>` follows all requirements of `std::variant`, unless otherwise noted.
* All `Ts\...` must satisfy all requirements on the corresponding parameter in `std::variant`, unless otherwise noted.

NOTE: See also: spec of https://eel.is/c++draft/variant[`std::variant`] and https://www.boost.org/doc/libs/develop/doc/html/variant/reference.html#variant.concepts[`boost::variant`]


[[rvariant.constructors]]
=== Constructors

[,cpp,subs="+macros"]
----
constexpr rvariant::rvariant() noexcept(/* see below */);pass:quotes[[.candidate\]#// 1#]
constexpr rvariant::rvariant(rvariant const&);pass:quotes[[.candidate\]#// 2#]
constexpr rvariant::rvariant(rvariant&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 3#]

template<class T>
constexpr rvariant(T&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 4#]

template<class T, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, Args&&...);pass:quotes[[.candidate\]#// 5#]

template<class T, class U, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U>, Args&&...);pass:quotes[[.candidate\]#// 6#]

template<std::size_t I, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, Args&&...);pass:quotes[[.candidate\]#// 7#]

template<std::size_t I, class U, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U>, Args&&...);pass:quotes[[.candidate\]#// 8#]

/* extensions */

// Flexible copy constructor
template<class... Us>
constexpr rvariant(rvariant<Us...> const& w);pass:quotes[[.candidate\]#// 9#]

// Flexible move constructor
template<class... Us>
constexpr rvariant(rvariant<Us...>&& w) noexcept(/* see below */);pass:quotes[[.candidate\]#// 10#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.ctor
* [.candidate]#1-8)#
include::_std-variant-proxy.adoc[]

* [.candidate]#9)# Flexible copy constructor.
+
*_Effects:_* If `w` holds a value, initializes the `rvariant` to hold the corresponding alternative as `w` and direct-initializes the contained value with `_GET_<j>(w)`, where `j` is `w.index()` and `_GET_` is defined as per https://eel.is/c++draft/variant.get[[variant.get\]]. Otherwise, initializes the `rvariant` to not hold a value.
+
*_Remarks:_*

** This constructor is defined as deleted unless `xref:#rvariant.helper.flexibility[subset_of]<rvariant<Us\...>, rvariant>` is `true` and `std::is_copy_constructible_v<U~_j_~>` is `true` for all _j_, where `U~_j_~` be the _j_^th^ type in `Us\...`.
** In case of duplicate alternative types, the corresponding index in `rvariant` shall be determined by the first occurrence of the same type in `Ts\...`.

* [.candidate]#10)# Flexible move constructor. Equivalent to #9, except that:
+
** `_GET_<j>(w)` is replaced with `_GET_<j>(std::move(w))`, and
** The exception specification is equivalent to the logical `AND` of `std::is_nothrow_move_constructible_v<U~_j_~>` for all _j_, where `U~_j_~` be the _j_^th^ type in `Us\...`.
--

Exceptions ::
+
[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.ctor
* [.candidate]#1-8)#
include::_std-variant-proxy.adoc[]

* [.candidate]#9)# Throws any exception thrown by direct-initializing any type in `Us\...`.

* [.candidate]#10)# Throws any exception thrown by move-constructing any type in `Us\...`.
--


[[rvariant.destructor]]
=== Destructor

[,cpp,subs="+macros"]
----
constexpr ~rvariant();pass:quotes[[.candidate\]#// 1#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.dtor
* [.candidate]#1)#
include::_std-variant-proxy.adoc[]
--


[[rvariant.assign]]
=== Assignment

[,cpp,subs="+macros"]
----
constexpr rvariant& operator=(rvariant const&);pass:quotes[[.candidate\]#// 1#]
constexpr rvariant& operator=(rvariant&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 2#]

template<class T> constexpr rvariant& operator=(T&&) noexcept(/* see below */);pass:quotes[[.candidate\]#// 3#]

/* extensions */

// Flexible copy assignment
template<class... Us>
constexpr rvariant& operator=(rvariant<Us...> const& w);pass:quotes[[.candidate\]#// 4#]

// Flexible move assignment
template<class... Us>
constexpr rvariant& operator=(rvariant<Us...>&& w) noexcept(/* see below */);pass:quotes[[.candidate\]#// 5#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.assign
* [.candidate]#1-3)#
include::_std-variant-proxy.adoc[]

* [.candidate]#4)# Flexible copy assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO

* [.candidate]#5)# Flexible move assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO
--


[[rvariant.mod]]
=== Modifiers

[,cpp,subs="+macros"]
----
template<class T, class... Args>
constexpr T& emplace(Args&&...);

template<class T, class U, class... Args>
constexpr T& emplace(std::initializer_list<U>, Args&&...);

template<std::size_t I, class... Args>
constexpr variant_alternative_t<I, rvariant<Types...>>&
  emplace(Args&&...);

template<std::size_t I, class U, class... Args>
constexpr variant_alternative_t<I, rvariant<Types...>>&
  emplace(std::initializer_list<U>, Args&&...);
----

:spec-url: https://eel.is/c++draft/variant.mod
include::_std-variant-proxy.adoc[]


[[rvariant.status]]
=== Value status

[,cpp,subs="+macros"]
----
constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;
----

:spec-url: https://eel.is/c++draft/variant.status
include::_std-variant-proxy.adoc[]


[[rvariant.subset]]
=== Subset

[,cpp,subs="+macros"]
----
template<class... Us>
  requires std::same_as<rvariant<Us...>, rvariant>
constexpr rvariant subset() const& noexcept(std::is_nothrow_copy_constructible_v<rvariant>);pass:quotes[[.candidate\]#// 1#]

template<class... Us>
  requires std::same_as<rvariant<Us...>, rvariant>
constexpr rvariant subset() && noexcept(std::is_nothrow_move_constructible_v<rvariant>);pass:quotes[[.candidate\]#// 2#]

template<class... Us>
  requires (!std::same_as<rvariant<Us...>, rvariant>)
constexpr rvariant<Us...> subset() const& noexcept(/* see below */);pass:quotes[[.candidate\]#// 3#]

template<class... Us>
  requires (!std::same_as<rvariant<Us...>, rvariant>)
constexpr rvariant<Us...> subset() && noexcept(/* see below */);pass:quotes[[.candidate\]#// 4#]
----

[.candidates]
--
* [.candidate]#1)# Returns `*this`.

* [.candidate]#2)# Returns `std::move(*this)`.

* [.candidate]#3)#
*_Mandates:_* `std::is_copy_constructible_v<U~_j_~>` is `true` for all _j_, where `U~_j_~` be the _j_^th^ type in `Us\...`.
+
*_Effects:_* If `*this` holds a value, returns an object of `rvariant<Us\...>` that holds the corresponding alternative as `*this` and whose contained value is direct-initialized with `_GET_<i>(*this)`, where `i` is `this\->index()` and `_GET_` is defined as per https://eel.is/c++draft/variant.get[[variant.get\]]. Otherwise, returns an object of `rvariant<Us\...>` that does not hold a value.
+
*_Remarks:_*

** This function does not participate in overload resolution unless `xref:#rvariant.helper.flexibility[subset_of]<rvariant<Us\...>, rvariant>` is `true`.

** If `pass:quotes[_equivalent-to_]<rvariant<Us\...>, rvariant>` is `true`, the exception specification is equivalent to the logical `AND` of `std::is_nothrow_copy_constructible_v<U~_j_~>` for all _j_. Otherwise, it is equivalent to `false`.

** In case of duplicate alternative types, the corresponding index on the returned `rvariant<Us\...>` object shall be determined by the first occurrence of the same type in `Us\...`.

* [.candidate]#4)# Equivalent to the overload #3, except that:
+
** `_GET_<i>(*this)` is replaced with `_GET_<i>(std::move(*this))`, and
** `std::is_copy_constructible_v` is replaced with `std::is_move_constructible_v`, and
** `std::is_nothrow_copy_constructible_v` is replaced with `std::is_nothrow_move_constructible_v`.
--

Exceptions ::
+
[.candidates]
--
* [.candidate]#1)# Throws any exception thrown by copy-constructing any type in `Us\...`.

* [.candidate]#2)# Throws any exception thrown by move-constructing any type in `Us\...`.

* [.candidate]#3)# Throws https://eel.is/c++draft/variant.bad.access[`std::bad_variant_access`] if `*this` holds an alternative that is not contained in `Us\...`; otherwise, throws any exception thrown by copy-constructing any type in `Us\...`.

* [.candidate]#4)# Throws https://eel.is/c++draft/variant.bad.access[`std::bad_variant_access`] if `*this` holds an alternative that is not contained in `Us\...`; otherwise, throws any exception thrown by move-constructing any type in `Us\...`.
--


[[rvariant.swap]]
=== Swap

[,cpp,subs="+macros"]
----
constexpr void swap(rvariant&) noexcept(/* see below */);
----

:spec-url: https://eel.is/c++draft/variant.swap
include::_std-variant-proxy.adoc[]


[[rvariant.visit]]
=== Visitation

[,cpp,subs="+macros"]
----
template<class Self, class Visitor>
constexpr decltype(auto) visit(this Self&&, Visitor&&);

template<class R, class Self, class Visitor>
constexpr R visit(this Self&&, Visitor&&);
----

:spec-url: https://eel.is/c++draft/variant.visit
include::_std-variant-proxy.adoc[]


[[rvariant.hash]]
=== Hash support

[,cpp,subs="+macros"]
----
namespace temp_ns {

template<class... Ts>
/* constexpr */ std::size_t hash_value(rvariant<Ts...> const& v);pass:quotes[[.candidate\]#// 1#]

} // temp_ns
----

[,cpp,subs="+macros"]
----
namespace std {

template<class... Ts>
struct hash<::temp_ns::rvariant<Ts...>>;pass:quotes[[.candidate\]#// 2#]

} // std
----

[.candidates]
--
* [.candidate]#1)# Equivalent to `std::hash<rvariant<Ts\...>>{}(v)`.
+
*_Note:_* Although the standard for `std::hash<std::variant<Ts\...>>` says it is not guaranteed to be `noexcept`, implementations tend to _strengthen_ the noexcept specifier, as it being technically allowed by the specification.

:spec-url: https://eel.is/c++draft/variant.hash
* [.candidate]#2)#
include::_std-variant-proxy.adoc[]
--


[[rvariant.helper]]
== `rvariant` helper utilities

[[rvariant.helper.flexibility]]
=== Flexibility traits

[,cpp,subs="+macros"]
----
template<class T, class U>
struct is_subset_of : std::false_type {};

template<
  template<class...> class TT, class... Ts,
  template<class...> class UU, class... Us
>
struct is_subset_of<TT<Ts...>, UU<Us...>> : std::true_type {};pass:quotes[[.candidate\]#// 1#]

template<class T, class U>
constexpr bool is_subset_of_v = is_subset_of<T, U>::value;

template<class T, class U>
concept subset_of = is_subset_of_v<T, U>;

template<class T, class U>
concept equivalent_to = subset_of<T, U> && subset_of<U, T>;pass:quotes[[.candidate\]#// 2#]
----

[.candidates]
--
* [.candidate]#1)# *_Constraints:_* For every type `U` in `Us\...`, there exists at least one type `T` in `Ts\...` such that `U` is the same type as `T`.

* [.candidate]#2)# `equivalent_to<T, U>` requires both `T` and `U` to TODO TODO TODO
--


[[rvariant.recursive]]
== Class template `recursive_wrapper`

[,cpp,subs="+macros"]
----
#include <compare>
#include <memory>

namespace temp_ns {

template<class T, class Allocator = std::allocator<T>>
class recursive_wrapper
{
  // provides the same functionality as https://eel.is/c+\+draft/indirect[`std::indirect`]
};

// equivalent to https://eel.is/c+\+draft/indirect[`std::indirect`]
template<class Value>
  recursive_wrapper(Value) -> recursive_wrapper<Value>;

// equivalent to https://eel.is/c++draft/indirect[`std::indirect`]
template<class Allocator, class Value>
  recursive_wrapper(std::allocator_arg_t, Allocator, Value)
    -> recursive_wrapper<
      Value,
      typename std::allocator_traits<Allocator>::template rebind_alloc<Value>
    >;

} // temp_ns
----

[,cpp,subs="+macros"]
----
namespace temp_ns::pmr {

template<class T>
using recursive_wrapper = ::temp_ns::recursive_wrapper<T, std::pmr::polymorphic_allocator<T>>;

} // temp_ns::pmr
----

[[rvariant.recursive.general]]
=== General

The class template `temp_ns::recursive_wrapper` and related components in the namespace scope provide same functionality and have equivalent requirements as `std::indirect`, except that:

* The class name is `recursive_wrapper`.
* `std::indirect` and `temp_ns::recursive_wrapper` are distinguishable in type level.

NOTE: `temp_ns::recursive_wrapper` is *NOT* a type alias of `std::indirect` because such a declaration will not satisfy the characteristics described above.

NOTE: Although `std::indirect` is a {cpp}26 feature, `temp_ns::recursive_wrapper` can be used in {cpp}20.


[[rvariant.recursive.hash]]
=== Hash support

[,cpp,subs="+macros"]
----
namespace temp_ns {

template<class T, class Allocator>
/* constexpr */ std::size_t hash_value(recursive_wrapper<T, Allocator> const& rw);pass:quotes[[.candidate\]#// 1#]

} // temp_ns
----

[,cpp,subs="+macros"]
----
namespace std {

template<class T, class Allocator>
struct hash<::temp_ns::recursive_wrapper<T, Allocator>>;pass:quotes[[.candidate\]#// 2#]

} // std
----

[.candidates]
--
* [.candidate]#1)# Equivalent to `std::hash<recursive_wrapper<T, Allocator>>{}(rw)`.
+
*_Note:_* Although the standard for `std::hash<std::indirect<T, Allocator>>` says it is not guaranteed to be `noexcept`, implementations tend to _strengthen_ the noexcept specifier, as it being technically allowed by the specification.

:spec-url: https://eel.is/c++draft/indirect.hash
* [.candidate]#2)#
include::_std-indirect-proxy.adoc[]
--


[[rvariant.pack]]
== Pack manipulation and deduping

[,cpp,subs="+macros"]
----
namespace temp_ns {

template<template<class...> class TT, class A, class B>
struct compact_alternative;pass:quotes[[.candidate\]#// 1#]

template<template<class...> class TT, class A, class B>
using compact_alternative_t = typename compact_alternative<TT, A, B>::type;

} // temp_ns
----

[.candidates]
--
* [.candidate]#1)# Effectively concatenates contained types in `A` and `B`, then dedupes them. If the resulting type list consists of only single type, unwraps the surrounding template.
+
_Formally:_  Let `Ts` denote an imaginary pack of types where `TT<Ts\...>` is the same type as `xref:#rvariant.xo.pack[_pack-union-t_]<TT, A, B>`. `compact_alternative` defines the member type `::type` as the first type in `Ts\...` if `sizeof\...(Ts) == 1`; otherwise, it is defined as `TT<Ts\...>`.
--

[NOTE]
.Notes on single-type variant
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be _unwrapped_ using `compact_alternative`. This is useful for resolving issues such as https://github.com/boostorg/spirit/issues/610[boostorg/spirit#610].


[[rvariant.io]]
== I/O
TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO


[[rvariant.xo]]
== Exposition-only utilities
This section demonstrates internal features used in the implementation.


[[rvariant.xo.pack]]
=== Pack utilities

[,cpp,subs="+macros"]
----
template<template<class...> class TT, class A, class B>
using pass:quotes[_pack-union-t_] = /* see below */; // exposition-onlypass:quotes[[.candidate\]#// 1#]
----

[.candidates]
--
* [.candidate]#1)# Let `As` denote the pack of template parameters of `A` if xref:#rvariant.xo.core[`_is-specialization-of<A, TT>_`], otherwise let `As` denote a pack of single type `A`. Let `Bs` denote likewise. `_pack-union-t_` is `TT<Ts\...>`, where `Ts\...` is the set union of `As\...` and `Bs\...` expanded from left to right. For duplicate types, the first occurrence shall remain in `Ts\...`.
--


[[rvariant.xo.core]]
=== Core type traits

[,cpp,subs="+macros"]
----
template<class T, template<class...> class TT>
struct pass:quotes[_is-ttp-specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 1#]

template<class T, template<auto...> class TT>
struct pass:quotes[_is-nttp-specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 2#]

template<class T, pass:quotes[_any-ttp_]>
struct pass:quotes[_is-specialization-of_]; // exposition-onlypass:quotes[[.candidate\]#// 3#]
----

[.candidates]
--
* [.candidate]#1-2)# Inherits `std::true_type` if and only if `T` is a specialization of `TT`; otherwise, `std::false_type`.

* [.candidate]#3)# If `_any-ttp_` is a template template parameter that consists of NTTP, equivalent to `_is-nttp-specialization-of_`; otherwise, equivalent to `_is-ttp-specialization-of_`.
--

NOTE: `_is-specialization-of_` is currently unimplementable due to lack of language feature; it requires C++26 reflection for a straightforward resolution. For now, it can be worked around by a compound `requires` expression.


= Additional information

== Benchmark

Non-recursive / Recursive

GCC / Clang / MSVC
