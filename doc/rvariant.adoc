= rvariant
Yaito Kakeyama; Nana Sakisaka
:doctype: book
:stylesheet: main.css
:source-highlighter: highlight.js
:highlightjs-theme: github
:icons: font
:sectanchors:
:idprefix:
:idseparator: -
:toc: left
:toc-title: rvariant
:toclevels: 2
:reproducible:

:boost-version: 1_88_0

:see-below: pass:quotes[[.see-below]#see below#]
:exposition-only: pass:quotes[[.exposition-only]#exposition only#]
:bad-variant-access: pass:quotes,macros[https://eel.is/c++draft/variant.bad.access[`std::bad_variant_access`]]

:unwrap_recursive_t: <<rvariant.recursive.helper,unwrap_recursive_t>>
:recursive_wrapper: <<rvariant.recursive,recursive_wrapper>>
:UNWRAP_RECURSIVE: pass:quotes[_xref:#rvariant.recursive.helper[UNWRAP_RECURSIVE]_]

`rvariant` is a variant library that supports recursive types. It is API-compatible with `std::variant` and includes Boost-style interfaces that act as proxies to the standard-compatible API.

[,cpp,subs="+macros,+attributes"]
----
// A common pattern for representing recursive ASTs using recursive variants.
struct BinaryExpr; enum class Op;
using Expr = temp_ns::rvariant<int, double, temp_ns::recursive_wrapper<BinaryExpr>>;
struct BinaryExpr { Expr lhs, rhs; Op op; };
----


[preface]
= Introduction

=== Motivation
Since its introduction in 2004, `boost::variant` has been used for a wide range of type-safe union use cases.

Starting with {cpp}17, most of those can be replaced with `std::variant`, _except_ for *recursive types*. As a result, many users of generic frameworks that require recursive variants--most notably Boost.Spirit--have continued using `boost::variant`, despite its significant impact on compile times.

The compile-time slowness of `boost::variant` stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with ``boost::variant``'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.

Until 2025, no one had managed to introduce a modern alternative into either Boost or the {cpp} standard. `rvariant` fills this gap with a new implementation that supports recursive types while remaining API-compatible with `std::variant`.


[#goals]
=== Project Goals
1. *Provide a modern, efficient, and battle-tested recursive variant library* to enable developers to avoid using Boost.Variant in new applications.

2. *Replace existing usages of Boost.Variant* in established frameworks, especially Boost.Spirit.X3.

3. *Explore potential directions for future standardization,* while gaining implementation experience with the modernized design.


[#comparison]
=== Comparison of Variant Libraries

[.scroll-x]
--
[frame=ends,cols=",,,,"]
|===
|
h| `*temp_ns::rvariant*`
h| https://en.cppreference.com/w/cpp/utility/variant.html[`*std::variant*`]
h| https://www.boost.org/doc/libs/{boost-version}/doc/html/variant.html[`*Boost.Variant*`]
h| https://www.boost.org/doc/libs/{boost-version}/libs/variant2/doc/html/variant2.html[`*Boost.Variant2*`]

s| Minimum C++ version
| {cpp}23
| {cpp}17
| {cpp}11 +
icon:warning[] Mostly legacy code from 2003
| {cpp}11

s| Compilation speed
| Fast
| Fast
| [.bad]*Very Slow*
| Fast

s| Interface for recursive types
| [.good]*Yes*
| [.bad]*No*
| https://www.boost.org/doc/libs/{boost-version}/doc/html/variant/tutorial.html#variant.tutorial.recursive[[.good]*Yes*]
| [.bad]*No*

s| May be valueless?
| Yes
| https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html[Yes]
| https://www.boost.org/doc/libs/{boost-version}/doc/html/variant/design.html#variant.design.never-empty[No]
| https://www.boost.org/doc/libs/{boost-version}/libs/variant2/doc/html/variant2.html#design_never_valueless[No]

s| Exception safety
| Basic exception safety
| Basic exception safety
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/{boost-version}/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution[(Temporary heap backup)]
| [.good]#Strong exception safety# +
https://www.boost.org/doc/libs/{boost-version}/libs/variant2/doc/html/variant2.html#design_strong_exception_safety[(Double storage)]

s| Flexible construction +
`V<A,B> = V<B,A>` +
`V<A,B,C> = V<A,B>`
| Yes
| [.bad]*No*
| Yes
| Yes
|===
--


[[rationale]]
## Rationale


[[why-is-recursive-wrapper-needed-1]]
### Why is recursive_wrapper needed?

A variant class cannot determine its storage's size when it contains incomplete types. Therefore, recursive alternatives always require a *recursive wrapper class* that holds the incomplete type by pointer and performs dynamic memory allocation on it.


[[why-is-recursive-wrapper-needed-2]]
### Why can't I just use std::unique_ptr instead of recursive_wrapper?

_Theoretically_, a recursive wrapper class can be designed independently, i.e. having no correlation to the variant class itself. So there's no theoretical reason to prevent you from using `std::unique_ptr` with `std::variant`.

However, *it is essential to have compatible interfaces in the variant class*, because the lack of interfaces means that you must:

* _wrap_ the actual type with the wrapper class every time you modify variants, and

* _unwrap_ the instance every time you access an alternative with `get()` or `visit()`.

In other words, the commonly seen advice like _"use std::unique_ptr if you want to hold recursive types in std::variant"_ is a _hack_ that basically does *nothing* except for just holding the wrapper instance. As said above, such unadapted wrappers introduce _intrusive_ boilerplates that infect the application layer, which is undesirable in practice.


[[why-is-rvariant-needed-1]]
### Why can't rvariant be a thin wrapper around std::variant?

Ultimately, `rvariant` is designed to be a strict superset of `std::variant`, not just to act as a third-party drop-in replacement.

If `rvariant` is specified correctly, it has the potential to become the *only variant library in the C++ standard* capable of handling _both_ recursive and non-recursive types transparently. However, if it is designed merely as a thin wrapper around `std::variant` (e.g. inheritance or composition), such a specification could never be standardized.

For this purpose, the documentation of `rvariant` is presented in a diff-style format that mirrors `std::variant`, with differences clearly marked using [.underline]#underlines#.


[[why-is-rvariant-needed-2]]
### Why can't rvariant be submitted directly to the C++ Standards Committee?

Historically, *the concept of recursive variants in {cpp} has been closely tied to https://www.boost.org/doc/libs/{boost-version}/doc/html/variant/tutorial.html#variant.tutorial.recursive[Boost.Variant] and link:pass:attributes[https://www.boost.org/doc/libs/{boost-version}/libs/spirit/doc/html/spirit/qi/tutorials/mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.the_structures][Boost.Spirit.Qi]*. It has been investigated, implemented, and used across Boost Libraries and by end users for _decades_. For this reason, we believe it's best to first gather feedback from the Boost community.

Moreover, we expect the working group to seek implementation experience, which inevitably involves the current state of Boost.Variant and related components. Submitting `rvariant` independently would likely result in the committee re-evaluating the outdated status quo. In our view, this could leave too much room for design ambiguity, potentially making the process unnecessarily time-consuming.


[[why-is-rvariant-needed-3]]
### Why is rvariant being proposed to Boost?

One of the co-authors of `rvariant`, Nana Sakisaka, has been contributing to the maintenance of Boost.Spirit since May 2025. Modernizing recursive variant support is a foundational part of upgrading the Boost.Spirit.X3 codebase, and has become a major technical interest in ongoing maintenance efforts.

Originally, `rvariant` was developed as an internal replacement within Boost.Spirit, as a sub-component with no broader exposure. However, it was later decided to submit it for formal review to benefit the wider community.

Although Boost.Spirit.X3 has a https://www.boost.org/doc/libs/{boost-version}/libs/spirit/doc/x3/html/spirit_x3/tutorials/rexpr.html[somewhat updated counterpart], it was never designed around a formal specification and still retains some https://github.com/boostorg/spirit/blob/328d940c372367a8d76a48ed956e870b56738ce9/include/boost/spirit/home/x3/support/ast/variant.hpp#L131[legacy implementation] from earlier stages of the development.

Boost.Spirit is just one example of a parser combinator library, and represents only the tip of the iceberg. Many kinds of libraries inherently require recursive variants: any library that constructs *statically typed recursive data structures* would benefit from them. Furthermore, once {cpp}26 reflection becomes available, such data structures will likely become even more common.

A proper solution to these challenges requires a fully-featured library, not just a value-semantic wrapper that happens to work for minimal use cases. We hope this work can serve as a starting point for broader discussion about recursive variants in Boost and beyond.


= Feature Cheat Sheet

This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.

== Basic Features

[,cpp,subs="+quotes,+macros,+attributes"]
----
using A = int;
using B = double;
struct C {};

using AB  = temp_ns::<<rvariant.rvariant,rvariant>><A, B>;
using BA  = temp_ns::rvariant<B, A>;
using ABC = temp_ns::rvariant<A, B, C>;

// <<rvariant.ctor,constructor>>
AB ab{42};

{
    AB local_ab{};
} // <<rvariant.dtor,destructor>>

ab<<rvariant.mod,.emplace>><int>(123);
ab<<rvariant.mod,.emplace>><0>(123);

// <<rvariant.assign,assignment>>
ab = AB{123};

// recursive types
{
    struct BinaryExpr; enum class Op;
    using Expr = temp_ns::rvariant<int, double, temp_ns::<<rvariant.recursive,recursive_wrapper>><BinaryExpr>>;
    struct BinaryExpr { Expr lhs, rhs; Op op; };
}

A& a = temp_ns::<<rvariant.get,get>><0>(ab);
A& a = temp_ns::get<A>(ab);
C& c = temp_ns::get<C>(ab);     // throws {bad-variant-access}

A* a = temp_ns::<<rvariant.get,get_if>><0>(&ab);
A* a = temp_ns::get_if<A>(&ab);
C* c = temp_ns::get_if<C>(&ab); // `nullptr`

// compatibility with boost; same effect as `get_if`
A* a = temp_ns::<<rvariant.get,get>><0>(&ab);
A* a = temp_ns::get<A>(&ab);
C* c = temp_ns::get<C>(&ab);    // `nullptr`

<<rvariant.TODO,ab == ab>>;
<<rvariant.TODO,ab < ab>>;
<<rvariant.TODO,ab <=> ab>>; // `requires (https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable[std::three_way_comparable]<Ts> && ...)`

auto visitor = temp_ns::<<rvariant.TODO,overloaded>> {
    [](A const& a) {},
    [](B const& b) {},
};

ab<<rvariant.visit,.visit>>(visitor);           // member visit
temp_ns::<<rvariant.visit,visit>>(visitor, ab); // function visit
----


== Advanced Features

[,cpp,subs="+quotes,+macros,+attributes"]
----
{
    // <<rvariant.ctor,flexible construction>>
    AB ab{BA{}};   // unordered construction
    ABC abc{AB{}}; // subset construction

    // <<rvariant.assign,flexible assignment>>
    ab = BA{};     // unordered assignment
    abc = AB{};    // subset assignment
}

static_assert(temp_ns::<<rvariant.syn,variant_size_v>><AB> == 2);
static_assert(std::same_as<temp_ns::<<rvariant.helper,variant_alternative_t>><0, AB>, A>);
static_assert(temp_ns::<<rvariant.get,holds_alternative>><A>(ab));

static_assert(!ab<<rvariant.status,.valueless_by_exception>>());
static_assert(ab<<rvariant.status,.index>>() != https://eel.is/c++draft/variant.syn[std::variant_npos]);

{
    AB tmp;
    ab<<rvariant.swap,.swap>>(tmp);
}
{
    using std::swap;
    AB tmp;
    <<rvariant.syn,swap>>(ab, tmp); // ADL
}

std::size_t _ = <<rvariant.hash,std::hash>><AB>{ab}();
std::size_t _ = <<rvariant.hash,hash_value>>(ab); // compatibility with boost

// <<rvariant.io,I/O support>>
{
    std::println("{}", AB{123});   // "123"
    std::cout << AB{123} << '\n';  // "123"

    // "type is A, value is 123" -- {cpp}26 reflection
    std::println("{:type is %t, value is %v}", AB{123}); // Note that %t prints `A`, not `int`

    std::println("{}", ABC{C{}});  // "C" -- {cpp}26 reflection
    std::cout << ABC{C{}} << '\n'; // "C" -- {cpp}26 reflection
}
----


[[rvariant]]
= Reference [.slug]##<<rvariant,[rvariant]>>##

NOTE: [.underline]#Underlined texts# indicate important characteristics of ``rvariant``'s extensions, in contrast to the `std::variant` counterparts.


[[rvariant.general]]
== General [.slug]##<<rvariant.general,[rvariant.general]>>##

* In <<rvariant,[rvariant]>>, `_GET_` denotes a set of exposition-only function templates (<<rvariant.get,[rvariant.get]>>).


[[rvariant.syn]]
== Header <temp_ns/rvariant.hpp> synopsis [.slug]##<<rvariant.syn,[rvariant.syn]>>##

[,cpp,subs="+macros,+attributes"]
----
#include <compare>
#include <memory>      // for pass:quotes[`std::allocator`], etc.
#include <type_traits> // for pass:quotes[`std::add_pointer`], etc.
#include <utility>     // for pass:quotes[`std::in_place_type`], etc.
#include <variant>     // for compatibility with {bad-variant-access}, etc.

namespace temp_ns {

// <<rvariant.rvariant,[rvariant.rvariant]>>, class template pass:quotes[`rvariant`]
template<class... Ts>
class rvariant;

// <<rvariant.recursive,[rvariant.recursive]>>, class template pass:quotes[`recursive_wrapper`]
template<class T, class Allocator = std::allocator<T>>
class recursive_wrapper;

/* all features commented below defined as per https://eel.is/c+\+draft/variant[[variant\]] */
    // variant_size, variant_size_v
    // operator==
    // operator!=
    // operator<
    // operator>
    // operator<=
    // operator>=
    // operator<=>
    // swap

https://eel.is/c++draft/variant.syn[/* not defined; use the pass:quotes[`std::`] versions instead */]
    // variant_npos
    // monostate and monostate-related functionalities
    // {bad-variant-access}

/* extensions */
/* behaves differently mostly because of the existence of pass:quotes[`recursive_wrapper`] */

// <<rvariant.helper,[rvariant.helper]>>, pass:quotes[`rvariant`] helper classes
template<std::size_t I, class T> struct variant_alternative; // not defined
template<std::size_t I, class T> struct variant_alternative<I, T const>;
template<std::size_t I, class T>
  using variant_alternative_t = typename variant_alternative<I, T>::type;

template<std::size_t I, class... Ts>
  struct variant_alternative<I, rvariant<Ts...>>;

// <<rvariant.get,[rvariant.get]>>, value access
template<class T, class... Ts>
  constexpr bool holds_alternative(rvariant<Ts...> const&) noexcept;

template<std::size_t I, class... Ts>
  constexpr variant_alternative_t<I, rvariant<Ts...>>&
    get(rvariant<Ts...>&);
template<std::size_t I, class... Ts>
  constexpr variant_alternative_t<I, rvariant<Ts...>>&&
    get(rvariant<Ts...>&&);
template<std::size_t I, class... Ts>
  constexpr variant_alternative_t<I, rvariant<Ts...>> const&
    get(rvariant<Ts...> const&);
template<std::size_t I, class... Ts>
  constexpr variant_alternative_t<I, rvariant<Ts...>> const&&
    get(rvariant<Ts...> const&&);

template<class T, class... Ts> constexpr T&        get(rvariant<Ts...>&);
template<class T, class... Ts> constexpr T&&       get(rvariant<Ts...>&&);
template<class T, class... Ts> constexpr T const&  get(rvariant<Ts...> const&);
template<class T, class... Ts> constexpr T const&& get(rvariant<Ts...> const&&);

template<std::size_t I, class... Ts>
  constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>>>
    get_if(rvariant<Ts...>*) noexcept;
template<std::size_t I, class... Ts>
  constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>> const>
    get_if(rvariant<Ts...> const*) noexcept;
template<std::size_t I, class... Ts>
  constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>>>
    pass:quotes[[.underline\]#get#](rvariant<Ts...>*) noexcept;       // compatibility with pass:quotes[`boost::get`]
template<std::size_t I, class... Ts>
  constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>> const>
    pass:quotes[[.underline\]#get#](rvariant<Ts...> const*) noexcept; // compatibility with pass:quotes[`boost::get`]

template<class T, class... Ts>
  constexpr std::add_pointer_t<T>
    get_if(rvariant<Ts...>*) noexcept;
template<class T, class... Ts>
  constexpr std::add_pointer_t<T const>
    get_if(rvariant<Ts...> const*) noexcept;
template<class T, class... Ts>
  constexpr std::add_pointer_t<T>
    pass:quotes[[.underline\]#get#](rvariant<Ts...>*) noexcept;       // compatibility with pass:quotes[`boost::get`]
template<class T, class... Ts>
  constexpr std::add_pointer_t<T const>
    pass:quotes[[.underline\]#get#](rvariant<Ts...> const*) noexcept; // compatibility with pass:quotes[`boost::get`]

// <<rvariant.visit,[rvariant.visit]>>, visitation
template<class Visitor, class... Variants>
  constexpr {see-below} visit(Visitor&&, Variants&&...);
template<class R, class Visitor, class... Variants>
  constexpr R visit(Visitor&&, Variants&&...);

// <<rvariant.hash,[rvariant.hash]>>, hash support
template<class... Ts>
  /* constexpr */ std::size_t hash_value(rvariant<Ts...> const&);

// <<rvariant.recursive.hash,[rvariant.recursive.hash]>>, hash support
template<class T, class Allocator>
  /* constexpr */ std::size_t hash_value(recursive_wrapper<T, Allocator> const&);

// ...
// TODO: I/O
// ...

// <<rvariant.recursive.helper,[rvariant.recursive.helper]>>, pass:quotes[`recursive_wrapper`] helper classes
template<class T> struct unwrap_recursive;
template<class T, class Allocator> struct unwrap_recursive<recursive_wrapper<T, Allocator>>;
template<class T> using unwrap_recursive_t = typename unwrap_recursive<T>::type;

// <<rvariant.pack,[rvariant.pack]>>, pack manipulation and deduping
template<template<class...> class TT, class A, class B>
  struct compact_alternative;
template<template<class...> class TT, class A, class B>
  using compact_alternative_t = typename compact_alternative<TT, A, B>::type;

} // temp_ns
----

[,cpp,subs="+macros,+attributes"]
----
namespace std {

// <<rvariant.hash,[rvariant.hash]>>, hash support
template<class... Ts> struct hash<::temp_ns::rvariant<Ts...>>;

// <<rvariant.recursive.hash,[rvariant.recursive.hash]>>, hash support
template<class T, class Allocator> struct hash<::temp_ns::recursive_wrapper<T, Allocator>>;

} // std
----


[[rvariant.rvariant]]
== Class template `rvariant` [.slug]##<<rvariant.rvariant,[rvariant.rvariant]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class... Ts>
class rvariant
{
public:
  // <<rvariant.ctor,[rvariant.ctor]>>, constructors
  constexpr rvariant::rvariant() noexcept({see-below});
  constexpr rvariant::rvariant(rvariant const&);
  constexpr rvariant::rvariant(rvariant&&) noexcept({see-below});

  template<class T>
    constexpr rvariant(T&&) noexcept({see-below});

  template<class T, class... Args>
    constexpr explicit rvariant(std::in_place_type_t<T>, Args&&...);
  template<class T, class U, class... Args>
    constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U>, Args&&...);
  template<std::size_t I, class... Args>
    constexpr explicit rvariant(std::in_place_index_t<I>, Args&&...);
  template<std::size_t I, class U, class... Args>
    constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U>, Args&&...);

  // <<rvariant.ctor,[rvariant.ctor]>>, flexible constructors
  template<class... Us>
    constexpr rvariant(rvariant<Us...> const& w);
  template<class... Us>
    constexpr rvariant(rvariant<Us...>&& w) noexcept({see-below});

  // <<rvariant.dtor,[rvariant.dtor]>>, destructor
  constexpr ~rvariant();

  // <<rvariant.assign,[rvariant.assign]>>, assignment
  constexpr rvariant& operator=(rvariant const&);
  constexpr rvariant& operator=(rvariant&&) noexcept({see-below});

  template<class T> constexpr rvariant& operator=(T&&) noexcept({see-below});

  // <<rvariant.assign,[rvariant.assign]>>, flexible assignment
  template<class... Us>
    constexpr rvariant& operator=(rvariant<Us...> const&);
  template<class... Us>
    constexpr rvariant& operator=(rvariant<Us...>&&) noexcept({see-below});

  // <<rvariant.mod,[rvariant.mod]>>, modifiers
  template<class T, class... Args>
    constexpr T& emplace(Args&&...);
  template<class T, class U, class... Args>
    constexpr T& emplace(std::initializer_list<U>, Args&&...);
  template<std::size_t I, class... Args>
    constexpr variant_alternative_t<I, rvariant<Ts...>>& emplace(Args&&...);
  template<std::size_t I, class U, class... Args>
    constexpr variant_alternative_t<I, rvariant<Ts...>>&
      emplace(std::initializer_list<U>, Args&&...);

  // <<rvariant.status,[rvariant.status]>>, value status
  constexpr bool valueless_by_exception() const noexcept;
  constexpr std::size_t index() const noexcept;

  // <<rvariant.subset,[rvariant.subset]>>, subset
  template<class... Us>
    constexpr rvariant<Us...> subset() const& noexcept({see-below});
  template<class... Us>
    constexpr rvariant<Us...> subset() && noexcept({see-below});

  // <<rvariant.swap,[rvariant.swap]>>, swap
  constexpr void swap(rvariant&) noexcept({see-below});

  // <<rvariant.visit,[rvariant.visit]>>, visitation
  template<class Self, class Visitor>
    constexpr decltype(auto) visit(this Self&&, Visitor&&);
  template<class R, class Self, class Visitor>
    constexpr R visit(this Self&&, Visitor&&);
};

} // temp_ns
----


[[rvariant.rvariant.general]]
=== General [.slug]##<<rvariant.rvariant.general,[rvariant.rvariant.general]>>##

* Class template `rvariant` follows all requirements of `std::variant`, unless otherwise noted.
* All types in `Ts` must satisfy all requirements on the corresponding parameter in `std::variant`, unless otherwise noted.
* [.underline]#Let `T` and `A` denote arbitrary types. If a user provides both `T` and `{recursive_wrapper}<T, A>` for the template parameter of `rvariant`, the program is ill-formed.#

NOTE: See also: spec of https://eel.is/c++draft/variant[`std::variant`] and https://www.boost.org/doc/libs/{boost-version}/doc/html/variant/reference.html#variant.concepts[`boost::variant`]


[[rvariant.ctor]]
=== Constructors [.slug]##<<rvariant.ctor,[rvariant.ctor]>>##

[,cpp,subs="+macros,+attributes"]
----
constexpr rvariant::rvariant() noexcept({see-below});pass:quotes[[.candidate\]#// 1#]
constexpr rvariant::rvariant(rvariant const& w);pass:quotes[[.candidate\]#// 2#]
constexpr rvariant::rvariant(rvariant&& w) noexcept({see-below});pass:quotes[[.candidate\]#// 3#]

template<class T>
constexpr rvariant(T&& t) noexcept({see-below});pass:quotes[[.candidate\]#// 4#]

template<class T, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, Args&&... args);pass:quotes[[.candidate\]#// 5#]

template<class T, class U, class... Args>
constexpr explicit rvariant(std::in_place_type_t<T>, std::initializer_list<U> il, Args&&...);pass:quotes[[.candidate\]#// 6#]

template<std::size_t I, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, Args&&... args);pass:quotes[[.candidate\]#// 7#]

template<std::size_t I, class U, class... Args>
constexpr explicit rvariant(std::in_place_index_t<I>, std::initializer_list<U> il, Args&&... args);pass:quotes[[.candidate\]#// 8#]

/* extensions */

// Flexible copy constructor
template<class... Us>
constexpr rvariant(rvariant<Us...> const& w);pass:quotes[[.candidate\]#// 9#]

// Flexible move constructor
template<class... Us>
constexpr rvariant(rvariant<Us...>&& w) noexcept({see-below});pass:quotes[[.candidate\]#// 10#]
----

[.candidates]
:spec-url: https://eel.is/c++draft/variant.ctor
* [.candidate]#1-3)#
include::_std-variant-proxy.adoc[]

* [.candidate]#4)# Equivalent to the `std::variant` counterpart, ^https://eel.is/c++draft/variant.ctor[[spec\]]^ except for:
+
*_Postconditions:_* `holds_alternative[.underline]##<{unwrap_recursive_t}<T~_j_~>>##(*this)` is `true`.

* [.candidate]#5)# [.underline]#Let `WT` denote `{recursive_wrapper}<T>` if there is any occurrence of `{recursive_wrapper}<T>` in `Ts\...`; otherwise, let `WT` denote `T`.#
+
*_Mandates:_* [.underline]#`T` is not a specialization of `{recursive_wrapper}`.#
+
*_Constraints:_*
+
--
[none]
** -- There is exactly one occurrence of `T` in [.underline]#`{unwrap_recursive_t}<Ts>\...`# and
** -- `std::is_constructible_v<[.underline]##WT##, Args\...>` is `true`.
--
+
*_Effects:_* Direct-non-list-initializes the contained value of type [.underline]#`WT`# with `std::forward<Args>(args)\...`.
+
*_Postconditions:_* `holds_alternative<T>(*this)` is `true`.
+
*_Throws:_* Any exception thrown by calling the selected constructor of [.underline]#`WT`#.
+
*_Remarks:_*  If [.underline]#`WT`#'s selected constructor is a constexpr constructor, this constructor is a constexpr constructor.

* [.candidate]#6)# [.underline]#Let `WT` denote `{recursive_wrapper}<T>` if there is any occurrence of `{recursive_wrapper}<T>` in `Ts\...`; otherwise, let `WT` denote `T`.#
+
*_Mandates:_* [.underline]#`T` is not a specialization of `{recursive_wrapper}`.#
+
*_Constraints:_*
+
--
[none]
** -- There is exactly one occurrence of `T` in [.underline]#`{unwrap_recursive_t}<Ts>\...`# and
** -- `std::is_constructible_v<[.underline]##WT##, std::initializer_list<U>&, Args\...>` is `true`.
--
+
*_Effects:_* Direct-non-list-initializes the contained value of type [.underline]#`WT`# with `il, std::forward<Args>(args)\...`.
+
*_Postconditions:_* `holds_alternative<T>(*this)` is `true`.
+
*_Throws:_* Any exception thrown by calling the selected constructor of [.underline]#`WT`#.
+
*_Remarks:_*  If [.underline]#`WT`#'s selected constructor is a constexpr constructor, this constructor is a constexpr constructor.

* [.candidate]#7-8)#
include::_std-variant-proxy.adoc[]

* [.candidate]#9)# _Flexible copy constructor_.
+
*_Effects:_* If `w` holds a value, initializes the `rvariant` to hold the [.underline]#alternative corresponding to that of# `w` and direct-initializes the contained value with `_GET_<j>(w)`, where `j` is `w.index()`. Otherwise, initializes the `rvariant` to not hold a value.
+
*_Throws:_* Any exception thrown by direct-initializing any type in [.underline]#`Us`#.
+
*_Remarks:_*
+
[none]
** -- This constructor is defined as deleted unless [.underline]#`<<rvariant.flex,subset_of>><rvariant<Us\...>, rvariant>` is `true` and# `std::is_copy_constructible_v[.underline]##<U~_j_~>##` is `true` for all [.underline]#_j_, where `U~_j_~` be the _j_^th^ type in `Us`#.

** -- [.underline]#The corresponding alternative for `rvariant` is the one that has the same type as the alternative held by the subject. In case of duplicate alternatives, the alternative index in `rvariant` shall be determined by the first occurrence of the same type in `Ts`.#

* [.candidate]#10)# _Flexible move constructor_.
+
Equivalent to #9, except for:
+
*_Effects:_* `_GET_<j>(w)` is replaced with `_GET_<j>(std::move(w))`.
+
*_Throws:_* Any exception thrown by move-constructing any type in [.underline]#`Us`#.
+
*_Remarks:_*
+
[none]
** -- The exception specification is equivalent to the logical `AND` of `std::is_nothrow_move_constructible_v[.underline]##<U~_j_~>##` for all [.underline]#_j_, where `U~_j_~` be the _j_^th^ type in `Us`#.


[[rvariant.dtor]]
=== Destructor [.slug]##<<rvariant.dtor,[rvariant.dtor]>>##

[,cpp,subs="+macros,+attributes"]
----
constexpr ~rvariant();pass:quotes[[.candidate\]#// 1#]
----

[.candidates]
--
:spec-url: https://eel.is/c++draft/variant.dtor
* [.candidate]#1)#
include::_std-variant-proxy.adoc[]
--


[[rvariant.assign]]
=== Assignment [.slug]##<<rvariant.assign,[rvariant.assign]>>##

[,cpp,subs="+macros,+attributes"]
----
constexpr rvariant& operator=(rvariant const&);pass:quotes[[.candidate\]#// 1#]
constexpr rvariant& operator=(rvariant&&) noexcept({see-below});pass:quotes[[.candidate\]#// 2#]

template<class T> constexpr rvariant& operator=(T&&) noexcept({see-below});pass:quotes[[.candidate\]#// 3#]

/* extensions */

// Flexible copy assignment operator
template<class... Us>
constexpr rvariant& operator=(rvariant<Us...> const& rhs);pass:quotes[[.candidate\]#// 4#]

// Flexible move assignment operator
template<class... Us>
constexpr rvariant& operator=(rvariant<Us...>&& rhs) noexcept({see-below});pass:quotes[[.candidate\]#// 5#]
----

[.candidates]
:spec-url: https://eel.is/c++draft/variant.assign
* [.candidate]#1-2)#
include::_std-variant-proxy.adoc[]

* [.candidate]#3)# Equivalent to the `std::variant` counterpart, ^https://eel.is/c++draft/variant.assign[[spec\]]^ except for:
+
*_Postconditions:_* `holds_alternative[.underline]##<{unwrap_recursive_t}<T~_j_~>>##(*this)` is `true`, with `T~_j_~` selected by the imaginary function overload resolution described above.

* [.candidate]#4)# _Flexible copy assignment operator_.
+
Let _j_ be `rhs.index()`. [.underline]#Let `U~_k_~` be the _k_^th^ type in `Us\...`.#
+
*_Constraints:_* [.underline]#`<<rvariant.flex,subset_of>><rvariant<Us\...>, rvariant>` is `true`.#
+
*_Effects:_*
+
--
[none]
** -- If neither `*this` nor `rhs` holds a value, there is no effect.
** -- Otherwise, if `*this` holds a value but `rhs` does not, destroys the value contained in `*this` and sets `*this` to not hold a value.
** -- Otherwise, if `rhs` holds the [.underline]#same alternative type# as `*this`, assigns the value contained in `rhs` to the value contained in `*this`. [.underline]#(_Note:_ `index()` is unchanged.)#
** -- Otherwise, if either `std::is_nothrow_copy_constructible_v<U~_j_~>` is `true` or `std::is_nothrow_move_constructible_v<U~_j_~>` is `false`, equivalent to pass:quotes[`emplace[.underline\]##&lt;__i__&gt;##(_GET_<_j_>(rhs))`] [.underline]#where _i_ is the corresponding index that is determined according to the rules defined in <<rvariant.ctor,the flexible copy constructor>>#.
** -- Otherwise, equivalent to `operator=([.underline]#rvariant&lt;Us\...&gt;#(rhs))`.
--
+
*_Postconditions:_* If `rhs.valueless_by_exception()` is `true`, `index() == rhs.index()`; [.underline]#otherwise, `*this` holds the same alternative type as `rhs`.#
+
*_Returns:_* `*this`.
+
*_Remarks:_* This operator is defined as deleted unless pass:quotes[`std::is_copy_constructible_v[.underline\]##&lt;U~_k_~&gt;## && std::is_copy_assignable_v[.underline\]##&lt;U~_k_~&gt;##`] is `true` for all [.underline]#_k_#.

* [.candidate]#5)# _Flexible move assignment operator_.
+
Let _j_ be `rhs.index()`. [.underline]#Let `U~_k_~` be the _k_^th^ type in `Us\...`.#
+
*_Constraints:_* [.underline]#`<<rvariant.flex,subset_of>><rvariant<Us\...>, rvariant>` is `true` and# pass:quotes[`std::is_move_constructible_v[.underline\]##&lt;U~_k_~&gt;## && std::is_move_assignable_v[.underline\]##&lt;U~_k_~&gt;##`] is `true` for all [.underline]#_k_#.
+
*_Effects:_*
+
--
[none]
** -- If neither `*this` nor `rhs` holds a value, there is no effect.
** -- Otherwise, if `*this` holds a value but `rhs` does not, destroys the value contained in `*this` and sets `*this` to not hold a value.
** -- Otherwise, if `rhs` holds the [.underline]#same alternative type# as `*this`, assigns pass:quotes[`_GET_<_j_>(std::move(rhs))`] to the value contained in `*this`. [.underline]#(_Note:_ `index()` is unchanged.)#
** -- Otherwise, equivalent to pass:quotes[`emplace[.underline\]##&lt;__i__&gt;##(_GET_<_j_>(std::move(rhs)))`] [.underline]#where _i_ is the corresponding index that is determined according to the rules defined in <<rvariant.ctor,the flexible move constructor>>#.
--
+
*_Returns:_* `*this`.
+
*_Remarks:_* The exception specification is equivalent to pass:quotes[`std::is_nothrow_move_constructible_v[.underline\]##&lt;U~_k_~&gt;## && std::is_nothrow_move_assignable_v[.underline\]##&lt;U~_k_~&gt;##`] for all [.underline]#_k_#.
+
--
[none]
** -- If an exception is throw during the call to ``U~_j_~``'s move construction (with _j_ being `rhs.index()`), the `rvariant` will hold no value.
** -- If an exception is thrown during the call to ``U~_j_~``'s move assignment, the state of the contained value is as defined by the exception safety guarantee of ``U~_j_~``'s move assignment; `index()` will be [.underline]#the corresponding index determined according to the rules defined in <<rvariant.ctor,the flexible move constructor>>.#
--


[[rvariant.mod]]
=== Modifiers [.slug]##<<rvariant.mod,[rvariant.mod]>>##

[,cpp,subs="+macros,+attributes"]
----
template<class T, class... Args>
constexpr T& emplace(Args&&... args);pass:quotes[[.candidate\]#// 1#]

template<class T, class U, class... Args>
constexpr T& emplace(std::initializer_list<U> il, Args&&... args);pass:quotes[[.candidate\]#// 2#]

template<std::size_t I, class... Args>
constexpr variant_alternative_t<I, rvariant<Ts...>>&
  emplace(Args&&... args);pass:quotes[[.candidate\]#// 3#]

template<std::size_t I, class U, class... Args>
constexpr variant_alternative_t<I, rvariant<Ts...>>&
  emplace(std::initializer_list<U> il, Args&&... args);pass:quotes[[.candidate\]#// 4#]
----

[.candidates]
:spec-url: https://eel.is/c++draft/variant.mod

* [.candidate]#1)# *_Mandates:_* [.underline]#`T` is not a specialization of `{recursive_wrapper}`.#
+
*_Constraints:_* `std::is_constructible_v<T, Args\...>` is `true`, and `T` occurs exactly once in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Effects:_* Equivalent to: +
pass:quotes[&nbsp;&nbsp;]`return emplace<__I__>(std::forward<Args>(args)\...);` +
where `_I_` is the zero-based index of `T` in [.underline]#`{unwrap_recursive_t}<Ts>`#.

* [.candidate]#2)# *_Mandates:_* [.underline]#`T` is not a specialization of `{recursive_wrapper}`.#
+
*_Constraints:_* `std::is_constructible_v<T, std::initializer_list<U>&, Args\...>` is `true`, and `T` occurs exactly once in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Effects:_* Equivalent to: +
pass:quotes[&nbsp;&nbsp;]`return emplace<__I__>(il, std::forward<Args>(args)\...);` +
where `_I_` is the zero-based index of `T` in [.underline]#`{unwrap_recursive_t}<Ts>`#.

* [.candidate]#3-4)#
include::_std-variant-proxy.adoc[]


[[rvariant.status]]
=== Value status [.slug]##<<rvariant.status,[rvariant.status]>>##

[,cpp,subs="+macros,+attributes"]
----
constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;
----

:spec-url: https://eel.is/c++draft/variant.status
include::_std-variant-proxy.adoc[]


[[rvariant.subset]]
=== Subset [.slug]##<<rvariant.subset,[rvariant.subset]>>##

[,cpp,subs="+macros,+attributes"]
----
template<class... Us>
  requires std::same_as<rvariant<Us...>, rvariant>
constexpr rvariant subset() const& noexcept(std::is_nothrow_copy_constructible_v<rvariant>);pass:quotes[[.candidate\]#// 1#]

template<class... Us>
  requires std::same_as<rvariant<Us...>, rvariant>
constexpr rvariant subset() && noexcept(std::is_nothrow_move_constructible_v<rvariant>);pass:quotes[[.candidate\]#// 2#]

template<class... Us>
  requires (!std::same_as<rvariant<Us...>, rvariant>)
constexpr rvariant<Us...> subset() const& noexcept({see-below});pass:quotes[[.candidate\]#// 3#]

template<class... Us>
  requires (!std::same_as<rvariant<Us...>, rvariant>)
constexpr rvariant<Us...> subset() && noexcept({see-below});pass:quotes[[.candidate\]#// 4#]
----

[.candidates]
* [.candidate]#1)# *_Returns:_* `*this`.
+
*_Throws:_* Any exception thrown by copy-constructing any type in `Us`.

* [.candidate]#2)# *_Returns:_* `std::move(*this)`.
+
*_Throws:_* Any exception thrown by move-constructing any type in `Us`.

* [.candidate]#3)#
*_Mandates:_* `std::is_copy_constructible_v[.underline]##<U~_j_~>##` is `true` for all [.underline]#_j_, where `U~_j_~` be the _j_^th^ type in `Us`#.
+
*_Effects:_* If `*this` holds a value, returns an `rvariant[.underline]##<Us\...>##` object that holds the [.underline]#alternative corresponding to that of# `*this`, with its contained value direct-initialized from `_GET_&lt;__i__&gt;(*this)`, where _i_ is `this\->index()`. Otherwise, returns an `rvariant[.underline]##<Us\...>##` object that does not hold a value.
+
*_Throws:_* {bad-variant-access} if `*this` holds an alternative that is not contained in [.underline]#`Us`#; otherwise, throws any exception thrown by copy-constructing any type in [.underline]#`Us`#.
+
*_Remarks:_*
+
--
[none]
** -- [.underline]#This function does not participate in overload resolution unless `<<rvariant.flex,subset_of>><rvariant<Us\...>, rvariant>` is `true`.#

** -- The exception specification is equivalent to the logical `AND` of `std::is_nothrow_copy_constructible_v[.underline]##<U~_j_~>##` for all [.underline]#_j_# [.underline]#If `<<rvariant.flex,equivalent_to>><rvariant<Us\...>, rvariant>` is `true`; otherwise, it is equivalent to `false`#.

** -- [.underline]#The corresponding index on the returned `rvariant<Us\...>` object shall be determined according to the rules defined in <<rvariant.ctor,the flexible copy constructor>>.#
--

* [.candidate]#4)# Equivalent to the overload #3, except for:
+
*_Effects:_* `_GET_&lt;__i__&gt;(*this)` is replaced with `_GET_&lt;__i__&gt;(std::move(*this))`.
+
*_Throws:_* {bad-variant-access} if `*this` holds an alternative that is not contained in [.underline]#`Us`#; otherwise, throws any exception thrown by move-constructing any type in [.underline]#`Us`#.
+
*_Remarks:_*
+
--
[none]
** -- `std::is_copy_constructible_v` is replaced with `std::is_move_constructible_v`, and
** -- `std::is_nothrow_copy_constructible_v` is replaced with `std::is_nothrow_move_constructible_v`.
--


[[rvariant.swap]]
=== Swap [.slug]##<<rvariant.swap,[rvariant.swap]>>##

[,cpp,subs="+macros,+attributes"]
----
constexpr void swap(rvariant&) noexcept({see-below});
----

:spec-url: https://eel.is/c++draft/variant.swap
include::_std-variant-proxy.adoc[]


[[rvariant.helper]]
== `rvariant` helper classes [.slug]##<<rvariant.helper,[rvariant.helper]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<std::size_t I, class T>
struct variant_alternative; // not defined

template<std::size_t I, class T>
struct variant_alternative<I, T const>;pass:quotes[[.candidate\]#// 1#]

template<std::size_t I, class... Ts>
struct variant_alternative<I, rvariant<Ts...>>;pass:quotes[[.candidate\]#// 2#]

} // temp_ns
----

[.candidates]
:spec-url: https://eel.is/c++draft/variant#helper-3
* [.candidate]#1)#
include::_std-variant-proxy.adoc[]

* [.candidate]#2)# The member typedef `type` denotes [.underline]#`{unwrap_recursive_t}<T~_I_~>`#.
+
*_Mandates:_* `I < sizeof\...(Ts)`.


[[rvariant.flex]]
== Flexibility traits [.slug]##<<rvariant.flex,[rvariant.flex]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class U, class T>
struct is_subset_of : std::false_type {};

template<
  template<class...> class UU, class... Us,
  template<class...> class TT, class... Ts
>
struct is_subset_of<UU<Us...>, TT<Ts...>> : std::true_type {};pass:quotes[[.candidate\]#// 1#]

template<class U, class T>
constexpr bool is_subset_of_v = is_subset_of<U, T>::value;

template<class U, class T>
concept subset_of = is_subset_of_v<U, T>;

template<class T, class U>
concept equivalent_to = subset_of<T, U> && subset_of<U, T>;

} // temp_ns
----

[.candidates]
* [.candidate]#1)# *_Constraints:_* For every type `U` in `Us`, there exists at least one type `T` in `Ts` such that `U` is the same type as `T`.


[[rvariant.get]]
== Value access [.slug]##<<rvariant.get,[rvariant.get]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class T, class... Ts>
constexpr bool holds_alternative(rvariant<Ts...> const& v) noexcept;

} // temp_ns
----

[.candidates]
* [.candidate]#{empty}# *_Mandates:_* The type `T` occurs exactly once in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Returns:_* `true` if `v.index()` is equal to the zero-based index of `T` in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Remarks:_* [.underline]#This function is defined as deleted if `T` is a specialization of `{recursive_wrapper}`.#


[,cpp,subs="+macros,+attributes"]
----
template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>>&
  pass:quotes[_GET_](rvariant<Ts...>& v);        // {exposition-only}

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>>&&
  pass:quotes[_GET_](rvariant<Ts...>&& v);       // {exposition-only}

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>> const&
  pass:quotes[_GET_](rvariant<Ts...> const& v);  // {exposition-only}

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>> const&&
  pass:quotes[_GET_](rvariant<Ts...> const&& v); // {exposition-only}
----

[.candidates]
* [.candidate]#{empty}# *_Mandates:_* `I < sizeof\...(Ts)`.
+
*_Preconditions:_* `v.index()` is `I`.
+
*_Returns:_* [.underline]#`{UNWRAP_RECURSIVE}(o)`, where `o` denotes a reference to the object stored in the `rvariant`#.


[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>>&
  get(rvariant<Ts...>& v);

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>>&&
  get(rvariant<Ts...>&& v);

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>> const&
  get(rvariant<Ts...> const& v);

template<std::size_t I, class... Ts>
constexpr variant_alternative_t<I, rvariant<Ts...>> const&&
  get(rvariant<Ts...> const&& v);

} // temp_ns
----

[.candidates]
* [.candidate]#{empty}# *_Mandates:_* `I < sizeof\...(Ts)`.
+
*_Effects:_* If `v.index()` is `I`, returns [.underline]#`{UNWRAP_RECURSIVE}(o)`, where `o` denotes a reference to the object stored in the `rvariant`#. Otherwise, throws an exception of type {bad-variant-access}.


[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class T, class... Ts> constexpr T&        get(rvariant<Ts...>& v);
template<class T, class... Ts> constexpr T&&       get(rvariant<Ts...>&& v);
template<class T, class... Ts> constexpr T const&  get(rvariant<Ts...> const& v);
template<class T, class... Ts> constexpr T const&& get(rvariant<Ts...> const&& v);

} // temp_ns
----

[.candidates]
* [.candidate]#{empty}# *_Mandates:_* The type `T` occurs exactly once in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Effects:_* [.underline]#Let `VT` denote the type of the value held by `v`. If `{unwrap_recursive_t}<VT>` is the same type as `T`#, returns [.underline]#`{UNWRAP_RECURSIVE}(o)`, where `o` denotes a reference to the object stored in the `rvariant`#. Otherwise, throws an exception of type {bad-variant-access}.
+
*_Remarks:_* [.underline]#This function is defined as deleted if `T` is a specialization of `{recursive_wrapper}`.#


[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<std::size_t I, class... Ts>
constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>>>
  get_if(rvariant<Ts...>*) noexcept;pass:quotes[[.candidate\]#// 1#]

template<std::size_t I, class... Ts>
constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>> const>
  get_if(rvariant<Ts...> const* v) noexcept;pass:quotes[[.candidate\]#// 2#]

template<std::size_t I, class... Ts>
constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>>>
  pass:quotes[[.underline\]#get#](rvariant<Ts...>*) noexcept;         // compatibility with pass:quotes[`boost::get`]pass:quotes[[.candidate\]#// 3#]

template<std::size_t I, class... Ts>
constexpr std::add_pointer_t<variant_alternative_t<I, rvariant<Ts...>> const>
  pass:quotes[[.underline\]#get#](rvariant<Ts...> const* v) noexcept; // compatibility with pass:quotes[`boost::get`]pass:quotes[[.candidate\]#// 4#]

} // temp_ns
----

[.candidates]
* [.candidate]#1-2)# *_Mandates:_* `I < sizeof\...(Ts)`.
+
*_Returns:_* A pointer to the value [.underline]#denoted by `{UNWRAP_RECURSIVE}(o)`, where `o` denotes a reference to the object stored in the `rvariant`#, if `v != nullptr` and `v\->index() == I`. Otherwise, returns `nullptr`.

* [.candidate]#3-4)# Provided for compatibility with `boost::get`.
+
*_Returns:_* `get_if<I>(v)`.


[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class T, class... Ts>
constexpr std::add_pointer_t<T>
  get_if(rvariant<Ts...>* v) noexcept;pass:quotes[[.candidate\]#// 1#]

template<class T, class... Ts>
constexpr std::add_pointer_t<T const>
  get_if(rvariant<Ts...> const* v) noexcept;pass:quotes[[.candidate\]#// 2#]

template<class T, class... Ts>
constexpr std::add_pointer_t<T>
  pass:quotes[[.underline\]#get#](rvariant<Ts...>* v) noexcept;       // compatibility with pass:quotes[`boost::get`]pass:quotes[[.candidate\]#// 3#]

template<class T, class... Ts>
constexpr std::add_pointer_t<T const>
  pass:quotes[[.underline\]#get#](rvariant<Ts...> const* v) noexcept; // compatibility with pass:quotes[`boost::get`]pass:quotes[[.candidate\]#// 4#]

} // temp_ns
----

[.candidates]
* [.candidate]#1-2)# *_Mandates:_* The type `T` occurs exactly once in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Effects:_* Equivalent to: `return get_if<__i__>(v);` with _i_ being the zero-based index of `T` in [.underline]#`{unwrap_recursive_t}<Ts>`#.
+
*_Remarks:_* [.underline]#This function is defined as deleted if `T` is a specialization of `{recursive_wrapper}`.#

* [.candidate]#3-4)# Provided for compatibility with `boost::get`.
+
*_Returns:_* `get_if<T>(v)`.


[[rvariant.visit]]
== Visitation [.slug]##<<rvariant.visit,[rvariant.visit]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class Visitor, class... Variants>
constexpr {see-below} visit(Visitor&& vis, Variants&&... vars);pass:quotes[[.candidate\]#// 1#]

template<class R, class Visitor, class... Variants>
constexpr R visit(Visitor&& vis, Variants&&... vars);pass:quotes[[.candidate\]#// 2#]

} // temp_ns

// below are member functions of the class template <<rvariant.rvariant,pass:quotes[`rvariant`]>>:

template<class Self, class Visitor>
constexpr decltype(auto) visit(this Self&& self, Visitor&& vis);pass:quotes[[.candidate\]#// 3#]

template<class R, class Self, class Visitor>
constexpr R visit(this Self&& self, Visitor&& vis);pass:quotes[[.candidate\]#// 4#]
----

[.candidates]
* [.candidate]#1-2)# Equivalent to the `std::variant` counterpart ^https://eel.is/c++draft/variant.visit[[spec\]]^, except that:
+
[none]
** -- `_GET_<__m__>(std::forward<V>(vars))` is replaced with `{UNWRAP_RECURSIVE}(_GET_<__m__>(std::forward<V>(vars)))`.

* [.candidate]#3-4)# Equivalent to the `std::variant` counterpart ^https://eel.is/c++draft/variant.visit[[spec\]]^, except that it forwards to `temp_ns::visit` instead of `std::visit`.


[[rvariant.hash]]
== Hash support [.slug]##<<rvariant.hash,[rvariant.hash]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class... Ts>
/* constexpr */ std::size_t hash_value(rvariant<Ts...> const& v);pass:quotes[[.candidate\]#// 1#]

} // temp_ns
----

[,cpp,subs="+macros,+attributes"]
----
namespace std {

template<class... Ts>
struct hash<::temp_ns::rvariant<Ts...>>;pass:quotes[[.candidate\]#// 2#]

} // std
----

[.candidates]
--
* [.candidate]#1)# *_Effects:_* Equivalent to `std::hash<rvariant<Ts\...>>{}(v)`.
+
*_Note:_* Although the standard for `std::hash<std::variant<Ts\...>>` says it is not guaranteed to be `noexcept`, implementations tend to _strengthen_ the noexcept specifier, as it being technically allowed by the specification.

:spec-url: https://eel.is/c++draft/variant.hash
* [.candidate]#2)#
include::_std-variant-proxy.adoc[]
--


[[rvariant.recursive]]
== Class template `recursive_wrapper` [.slug]##<<rvariant.recursive,[rvariant.recursive]>>##

[,cpp,subs="+macros,+attributes"]
----
#include <compare>
#include <memory>

namespace temp_ns {

template<class T, class Allocator = std::allocator<T>>
class recursive_wrapper
{
  // provides the same functionality as https://eel.is/c+\+draft/indirect[`std::indirect`]
};

// equivalent to the https://eel.is/c+\+draft/indirect[`std::indirect`] counterpart
template<class Value>
  recursive_wrapper(Value) -> recursive_wrapper<Value>;

// equivalent to the https://eel.is/c++draft/indirect[`std::indirect`] counterpart
template<class Allocator, class Value>
  recursive_wrapper(std::allocator_arg_t, Allocator, Value)
    -> recursive_wrapper<
      Value,
      typename std::allocator_traits<Allocator>::template rebind_alloc<Value>
    >;

} // temp_ns
----

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns::pmr {

template<class T>
using recursive_wrapper = ::temp_ns::recursive_wrapper<T, std::pmr::polymorphic_allocator<T>>;

} // temp_ns::pmr
----

[[rvariant.recursive.general]]
=== General [.slug]##<<rvariant.recursive.general,[rvariant.recursive.general]>>##

The class template `temp_ns::recursive_wrapper` and relevant components in the namespace scope provide same functionality and have equivalent requirements as `std::indirect`, except that:

[none]
* -- The class name is `recursive_wrapper`.
* -- `std::indirect` and `temp_ns::recursive_wrapper` are distinguishable in type level.

NOTE: `temp_ns::recursive_wrapper` is designed to be *NOT* a type alias of `std::indirect` because such a declaration would not satisfy the characteristics described above.

NOTE: Although `std::indirect` is a {cpp}26 feature, `temp_ns::recursive_wrapper` can be used in {cpp}23.


[[rvariant.recursive.hash]]
=== Hash support [.slug]##<<rvariant.recursive.hash,[rvariant.recursive.hash]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class T, class Allocator>
/* constexpr */ std::size_t hash_value(recursive_wrapper<T, Allocator> const& rw);pass:quotes[[.candidate\]#// 1#]

} // temp_ns
----

[,cpp,subs="+macros,+attributes"]
----
namespace std {

template<class T, class Allocator>
struct hash<::temp_ns::recursive_wrapper<T, Allocator>>;pass:quotes[[.candidate\]#// 2#]

} // std
----

[.candidates]
--
* [.candidate]#1)# Equivalent to `std::hash<recursive_wrapper<T, Allocator>>{}(rw)`.
+
*_Note:_* Although the standard for `std::hash<std::indirect<T, Allocator>>` says it is not guaranteed to be `noexcept`, implementations tend to _strengthen_ the noexcept specifier, as it being technically allowed by the specification.

:spec-url: https://eel.is/c++draft/indirect.hash
* [.candidate]#2)#
include::_std-indirect-proxy.adoc[]
--


[[rvariant.recursive.helper]]
== `recursive_wrapper` helper classes [.slug]##<<rvariant.recursive.helper,[rvariant.recursive.helper]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<class T>
struct unwrap_recursive
{
  using type = T;
};

template<class T, class Allocator>
struct unwrap_recursive<recursive_wrapper<T, Allocator>>
{
  using type = T;
};

} // temp_ns
----

[,cpp,subs="+macros,+attributes"]
----
template<class T>
constexpr {see-below} pass:quotes[_UNWRAP_RECURSIVE_](T&& o) noexcept; // {exposition-only}
----

[.candidates]
* [.candidate]#{empty}# *_Effects:_* Denotes `*o`, if cv-unqualified non-reference type for `T` is a specialization of `{recursive_wrapper}`. Otherwise, denotes `o`.


[[rvariant.pack]]
== Pack manipulation and deduping [.slug]##<<rvariant.pack,[rvariant.pack]>>##

[,cpp,subs="+macros,+attributes"]
----
namespace temp_ns {

template<template<class...> class TT, class A, class B>
struct compact_alternative;

} // temp_ns
----

[.candidates]
* [.candidate]#{empty}# Effectively concatenates contained types in `A` and `B`, then dedupes them. If the resulting type list consists of only a single type, the surrounding template is unwrapped.
+
*_Definition:_*  Let `Ts` denote an imaginary pack of types where `TT<Ts\...>` is the same type as `<<rvariant.xo.pack,_pack-union-t_>><TT, A, B>`. The member typedef `type` denotes `Ts\...[0]` if `sizeof\...(Ts) == 1`; otherwise, the member typedef `type` denotes `TT<Ts\...>`.

[NOTE]
.Notes on single-type variant
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be _unwrapped_ using `compact_alternative`. This is useful for resolving issues such as https://github.com/boostorg/spirit/issues/610[boostorg/spirit#610].

[WARNING]
`compact_alternative` does not unwrap `{recursive_wrapper}`. This is intentional, because doing so could lead to instantiating incomplete type on undesired timings. You may apply `{unwrap_recursive_t}` manually.


[[rvariant.io]]
== I/O [.slug]##<<rvariant.io,[rvariant.io]>>##
TODO


[[rvariant.xo]]
== Exposition-only utilities [.slug]##<<rvariant.xo,[rvariant.xo]>>##
This section demonstrates internal features used in the implementation.


[[rvariant.xo.pack]]
=== Pack utilities [.slug]##<<rvariant.xo.pack,[rvariant.xo.pack]>>##

[,cpp,subs="+macros,+attributes"]
----
template<template<class...> class TT, class A, class B>
using pass:quotes[_pack-union-t_] = {see-below}; // {exposition-only}
----

[.candidates]
* [.candidate]#{empty}# Let `As` denote the pack of template parameters of `A` if `A` is a specialization of `TT`, otherwise let `As` denote a pack of single type `A`. Let `Bs` denote likewise. `_pack-union-t_` denotes `TT<Ts\...>`, where `Ts\...` is the set union of `As\...` and `Bs\...` expanded from left to right. For duplicate types, the first occurrence shall remain in `Ts\...`.


[[rvariant.xo.core]]
=== Core type traits [.slug]##<<rvariant.xo.core,[rvariant.xo.core]>>##

[,cpp,subs="+macros,+attributes"]
----
template<class T, template<class...> class TT>
struct pass:quotes[_is-ttp-specialization-of_];  // {exposition-only}pass:quotes[[.candidate\]#// 1#]

template<class T, template<auto...> class TT>
struct pass:quotes[_is-nttp-specialization-of_]; // {exposition-only}pass:quotes[[.candidate\]#// 2#]

template<class T, pass:quotes[_any-ttp_]>
struct pass:quotes[_is-specialization-of_];      // {exposition-only}pass:quotes[[.candidate\]#// 3#]
----

[.candidates]
--
* [.candidate]#1-2)# Inherits `std::true_type` if and only if `T` is a specialization of `TT`; otherwise, inherits `std::false_type`.

* [.candidate]#3)# If `_any-ttp_` is a template template parameter that consists of NTTP, equivalent to `_is-nttp-specialization-of_`; otherwise, equivalent to `_is-ttp-specialization-of_`.
--

NOTE: `_is-specialization-of_` requires {cpp}26 reflection for a straightforward resolution. For older versions, it can be worked around by a compound `requires` expression.


= Additional Information

[[benchmark]]
== Benchmark

Non-recursive / Recursive

GCC / Clang / MSVC


[[about]]
== About the Authors

Yaito Kakeyama is a {cpp} enthusiast with a strong interest in language design and modern library development. He has contributed to several public efforts in the {cpp} community, including co-authoring LWG 4166 with Nana Sakisaka and submitting occasional compiler bug reports. He is the co-author of `rvariant` and has been deeply involved in its implementation.

Nana Sakisaka has taken on an active maintainer role in Boost.Spirit since May 2025. The development of `rvariant` began as part of a broader effort to modernize the Boost.Spirit.X3 codebase. He is the co-author of `rvariant` and has focused on its rationale and specification wording.
