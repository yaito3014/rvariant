<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="author" content="Yaito Kakeyama, Nana Sakisaka">
<title>rvariant</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

body {
  font-size: 12.8px;
  font-family: DejaVuSans, 'DejaVu Sans', sans-serif;
  color: rgb(11, 11, 11);
}

h1, h2, p, td.content, span.alt, summary {
  letter-spacing: inherit;
}

p strong, td.content strong, div.footnote strong {
  letter-spacing: inherit;
}

.quoteblock .attribution cite, .verseblock .attribution cite {
  letter-spacing: inherit;
}

p, td.content {
  font-size: inherit;
}

a {
  text-decoration-skip-ink: none;
}

dt {
  font-size: 1.3em;
}

:where(th, td):has(.good) {
  background-color: rgb(202, 255, 255);
}

:where(th, td):has(.bad) {
  background-color: rgb(255, 213, 213);
}

table.params tr th, table.params tr td {
  padding: .2em .25em;
}

code {
  font-family: 'DejaVu Sans Mono', monospace;
  max-width: 800px;
}

:not(pre):not([class^=L]) > code {
  background: rgb(239, 239, 241);
  border-radius: 0;
}

:is(#fakeId, pre) code {
  position: relative;
}

:is(#fakeId, pre) code:has(.candidate) {
  padding-right: 4em;
}

code .candidate {
  display: inline-flex;
  position: absolute;
  right: 0;

  user-select: none;
  margin-right: 1em;
}

li p:has(+ .ulist) {
  margin-bottom: 0;
}

.candidate .hljs-comment {
  font-style: normal;
  font-weight: bold;
  color: #008000;
}

.candidates .content > .ulist > ul {
  list-style-type: none;
}

.candidates .content > .ulist > ul > li {
  padding-left: 3rem;
  text-indent: -5.25rem;
}

.candidates .content > .ulist > ul > li :is(.paragraph, ul) {
  text-indent: 0;
}

.candidates .candidate {
  display: inline-block;
  width: 5rem;
  text-align: right;
  text-indent: 0;
  font-weight: bold;
}

.conum[data-value] {
  background: rgba(0, 0, 0, 0.6);
}

.listingblock:hover code[data-lang]::before {
  display: none;
}

.small-note {
  font-size: 0.9em;
  opacity: 0.8;
}

.scroll-x {
  overflow-x: auto;
}

#toc.toc2 > ul {
  font-size: inherit;
}

#toc.toc2 #toctitle {
  font-size: 1.375em;
}

#feature-overview ~ * code a {
  font-weight: bold;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>rvariant</h1>
<div class="details">
<span id="author" class="author">Yaito Kakeyama</span><br>
<span id="author2" class="author">Nana Sakisaka</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">rvariant</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#motivation">Motivation</a></li>
<li><a href="#goals">Project goals</a></li>
<li><a href="#comparison">Comparison of variant libraries</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel1">
<li><a href="#feature-cheat-sheet">Feature cheat sheet</a></li>
<li><a href="#rvariant.syn">Header &lt;temp_ns/rvariant.hpp&gt; synopsis</a></li>
<li><a href="#rvariant.rvariant">Class template <code>rvariant</code></a>
<ul class="sectlevel2">
<li><a href="#rvariant.requirements">Requirements</a></li>
<li><a href="#rvariant.constructors">Constructors</a></li>
<li><a href="#rvariant.destructor">Destructor</a></li>
<li><a href="#rvariant.assign">Assignment</a></li>
<li><a href="#rvariant.mod">Modifiers</a></li>
<li><a href="#rvariant.status">Value status</a></li>
<li><a href="#rvariant.swap">Swap</a></li>
<li><a href="#rvariant.visit">Visitation</a></li>
</ul>
</li>
<li><a href="#rvariant.recursive">Class template <code>recursive_wrapper</code></a>
<ul class="sectlevel2">
<li><a href="#constructors">Constructors</a></li>
</ul>
</li>
<li><a href="#rvariant.pack">Pack manipulation and deduping</a></li>
<li><a href="#rvariant.io">I/O</a></li>
<li><a href="#rvariant.xo">Exposition-only utilities</a>
<ul class="sectlevel2">
<li><a href="#rvariant.xo.flexibility">Flexibility traits</a></li>
<li><a href="#rvariant.xo.core">Core type traits</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-information">Additional information</a>
<ul class="sectlevel1">
<li><a href="#benchmark">Benchmark</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>rvariant</code> is a variant library that supports recursive types. It is API-compatible with <code>std::variant</code> and includes Boost-style interfaces that act as proxies to the standard-compatible API.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="motivation"><a class="anchor" href="#motivation"></a>Motivation</h3>
<div class="paragraph">
<p>Since its introduction in 2004, <code>boost::variant</code> has been used for a wide range of type-safe union use cases.</p>
</div>
<div class="paragraph">
<p>Starting with C&#43;&#43;17, most of those can be replaced with <code>std::variant</code>, <em>except</em> for <strong>recursive types</strong>. As a result, many users of generic frameworks that inherently require recursive variants&#8212;&#8203;most notably Boost.Spirit&#8212;&#8203;have continued using <code>boost::variant</code>, despite its significant impact on compile times.</p>
</div>
<div class="paragraph">
<p>The compile-time slowness of <code>boost::variant</code> stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with <code>boost::variant</code>'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.</p>
</div>
<div class="paragraph">
<p>Until 2025, no one had managed to introduce a modern alternative into either Boost or the C&#43;&#43; standard. <code>rvariant</code> fills this gap with a new implementation that supports recursive types while remaining API-compatible with <code>std::variant</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="goals"><a class="anchor" href="#goals"></a>Project goals</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Provide a modern, efficient, and battle-tested recursive variant library to enable developers to avoid using Boost.Variant in new applications.</p>
</li>
<li>
<p>Replace existing usages of Boost.Variant in established frameworks, especially Boost.Spirit.X3.</p>
</li>
<li>
<p>Gain implementation experience with a recursive variant library to explore potential directions for future standardization.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="comparison"><a class="anchor" href="#comparison"></a>Comparison of variant libraries</h3>
<div class="openblock scroll-x">
<div class="content">
<table class="tableblock frame-ends grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code><strong>temp_ns::rvariant</strong></code></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant.html"><code><strong>std::variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/variant.html"><code><strong>Boost.Variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html"><code><strong>Boost.Variant2</strong></code></a></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Required Version</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11<br>
<span class="icon"><i class="fa fa-warning"></i></span> Mostly legacy code from 2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compilation Speed</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">Very Slow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Can hold recursive types?</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="good">Yes</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/boost/recursive_wrapper.html"><strong class="good">Yes</strong></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>May be valueless?</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html">Yes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty">No</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_never_valueless">No</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Exception Safety</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="good">Strong exception safety</span><br>
<a href="https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution">(Temporary heap backup)</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="good">Strong exception safety</span><br>
<a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_strong_exception_safety">(Double storage)</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Allows flexible construction<br>
<code>V&lt;A,B&gt; = V&lt;B,A&gt;</code><br>
<code>V&lt;A,B,C&gt; = V&lt;A,B&gt;</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A variant class cannot determine its own size when it contains incomplete types. Therefore, recursive variants always require dynamic memory allocation.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0"><a class="anchor" href="#reference"></a>Reference</h1>
<div class="sect1">
<h2 id="feature-cheat-sheet"><a class="anchor" href="#feature-cheat-sheet"></a>Feature cheat sheet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.</p>
</div>
<h3 id="basic-features" class="discrete">Basic features</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">using A = int;
using B = double;
struct C {};

using AB  = temp_ns::<a href="#rvariant.rvariant">rvariant</a>&lt;A, B&gt;;
using BA  = temp_ns::rvariant&lt;B, A&gt;;
using ABC = temp_ns::rvariant&lt;A, B, C&gt;;

// <a href="#rvariant.constructors">constructor</a>
AB ab{42};

{
    AB local_ab{};
} // <a href="#rvariant.destructor">destructor</a>

ab<a href="#rvariant.mod">.emplace&lt;int&gt;(123)</a>;
ab<a href="#rvariant.mod">.emplace&lt;0&gt;(123)</a>;

// <a href="#rvariant.assign">assignment</a>
ab = AB{123};

// recursive types
{
    struct BinaryExpr;
    using Expr = temp_ns::rvariant&lt;A, B, C, temp_ns::<a href="#rvariant.recursive">recursive_wrapper</a>&lt;BinaryExpr&gt;&gt;;
    struct BinaryExpr { Expr lhs, rhs; };
}

A&amp; a = temp_ns::<a href="#rvariant.syn">get</a>&lt;0&gt;(ab);
A&amp; a = temp_ns::get&lt;A&gt;(ab);
C&amp; c = temp_ns::get&lt;C&gt;(ab);     // throws <a href="https://en.cppreference.com/w/cpp/utility/variant/bad_variant_access.html"><code>std::bad_variant_access</code></a>

A* a = temp_ns::<a href="#rvariant.syn">get_if</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get_if&lt;A&gt;(&amp;ab);
C* c = temp_ns::get_if&lt;C&gt;(&amp;ab); // <code>nullptr</code>

// compatibility with boost; same effect as <code>get_if</code>
A* a = temp_ns::<a href="#rvariant.syn">get</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get&lt;A&gt;(&amp;ab);
C* c = temp_ns::get&lt;C&gt;(&amp;ab);    // <code>nullptr</code>

<a href="#rvariant.syn">ab == ab</a>;
<a href="#rvariant.syn">ab &lt; ab</a>;
<a href="#rvariant.syn">ab &lt;=&gt; ab</a>; // <code>requires (<a href="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable">std::three_way_comparable</a>&lt;Ts&gt; &amp;&amp; ...)</code>

auto visitor = temp_ns::<a href="#rvariant.utility-todo">overloaded</a> {
    [](A const&amp; a) {},
    [](B const&amp; b) {},
};

ab<a href="#rvariant.visit">.visit(visitor)</a>;           // member visit
temp_ns::<a href="#rvariant.syn">visit</a>(visitor, ab); // function visit</code></pre>
</div>
</div>
<h3 id="advanced-features" class="discrete">Advanced features</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">{
    // <a href="#rvariant.constructors">flexible construction</a>
    AB ab{BA{}};   // unordered construction
    ABC abc{AB{}}; // subset construction

    // <a href="#rvariant.assign">flexible assignment</a>
    ab = BA{};     // unordered assignment
    abc = AB{};    // subset assignment
}

static_assert(temp_ns::<a href="#rvariant.syn">variant_size_v</a>&lt;AB&gt; == 2);
static_assert(std::same_as&lt;temp_ns::<a href="#rvariant.syn">variant_alternative_t</a>&lt;0, AB&gt;, A&gt;);
static_assert(temp_ns::<a href="#rvariant.syn">holds_alternative</a>&lt;A&gt;(ab));

static_assert(ab<a href="#rvariant.status">.index()</a> != <a href="https://en.cppreference.com/w/cpp/utility/variant/variant_npos">std::variant_npos</a>);
static_assert(!ab<a href="#rvariant.status">.valueless_by_exception()</a>);

{
    AB tmp;
    ab<a href="#rvariant.swap">.swap(tmp)</a>;
}
{
    using std::swap;
    AB tmp;
    <a href="#rvariant.syn">swap</a>(ab, tmp); // ADL
}

std::size_t _ = <a href="#rvariant.syn">std::hash&lt;AB&gt;{ab}</a>();
std::size_t _ = <a href="#rvariant.syn">hash_value(ab)</a>; // compatibility with boost

// <a href="#rvariant.io">I/O support</a>
{
    std::println("{}", AB{123});   // "123"
    std::cout &lt;&lt; AB{123} &lt;&lt; '\n';  // "123"

    // "type is A, value is 123" -- C&#43;&#43;26 reflection
    std::println("{:type is %t, value is %v}", AB{123}); // Note that %t prints <code>A</code>, not <code>int</code>

    std::println("{}", ABC{C{}});  // "C" -- C&#43;&#43;26 reflection
    std::cout &lt;&lt; ABC{C{}} &lt;&lt; '\n'; // "C" -- C&#43;&#43;26 reflection
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.syn"><a class="anchor" href="#rvariant.syn"></a>Header &lt;temp_ns/rvariant.hpp&gt; synopsis</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;compare&gt;
#include &lt;utility&gt; // for `std::in_place_type`, etc.
#include &lt;variant&gt; // for compatibility with `std::bad_variant_access`

namespace temp_ns {

// <a href="#rvariant.rvariant">class template <code>rvariant</code></a>
template&lt;class... Ts&gt;
class rvariant;

<a href="https://eel.is/c++draft/variant.syn">/* all features commented below defined as per standard */</a>
    // variant_size, variant_size_v
    // variant_alternative, variant_alternative_v
    // get
    // get_if

    // operator==
    // operator!=
    // operator&lt;
    // operator&gt;
    // operator&lt;=
    // operator&gt;=
    // operator&lt;=&gt;

    // visit
    // swap
    // hash

/* extension */

template&lt;std::size_t I, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt;*) noexcept;       // delegates to `get_if`

template&lt;std::size_t I, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt; const*) noexcept; // delegates to `get_if`

template&lt;class T, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt;*) noexcept;       // delegates to `get_if`

template&lt;class T, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt; const*) noexcept; // delegates to `get_if`

// ...
// TODO: I/O
// ...

<a href="https://eel.is/c++draft/variant.syn">/* not defined; use the <code>std::</code> versions instead */</a>
    // variant_npos
    // monostate and monostate-related functionalities
    // bad_variant_access

} // temp_ns</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.rvariant"><a class="anchor" href="#rvariant.rvariant"></a>Class template <code>rvariant</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;class... Ts&gt;
class rvariant
{
public:
    // <a href="#rvariant.constructors">constructors</a>
    constexpr rvariant::rvariant() noexcept(/* see below */);
    constexpr rvariant::rvariant(rvariant const&amp;);
    constexpr rvariant::rvariant(rvariant&amp;&amp;) noexcept(/* see below */);

    template&lt;class T&gt;
      constexpr rvariant(T&amp;&amp;) noexcept(/* see below */);

    template&lt;class T, class... Args&gt;
      constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
    template&lt;class T, class U, class... Args&gt;
      constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
    template&lt;std::size_t I, class... Args&gt;
      constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
    template&lt;std::size_t I, class U, class... Args&gt;
      constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

    /* extensions */
    template&lt;class... Us&gt;
      constexpr rvariant(rvariant&lt;Us...&gt; const&amp; w);
    template&lt;class... Us&gt;
      constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);

    // <a href="#rvariant.destructor">destructor</a>
    constexpr ~rvariant();

    // <a href="#rvariant.assign">assignment</a>
    constexpr rvariant&amp; operator=(rvariant const&amp;);
    constexpr rvariant&amp; operator=(rvariant&amp;&amp;) noexcept(/* see below */);

    template&lt;class T&gt; constexpr rvariant&amp; operator=(T&amp;&amp;) noexcept(/* see below */);

    /* extensions */
    template&lt;class... Us&gt;
      constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp; w);
    template&lt;class... Us&gt;
      constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);

    // <a href="#rvariant.mod">modifiers</a>
    template&lt;class T, class... Args&gt;
      constexpr T&amp; emplace(Args&amp;&amp;...);
    template&lt;class T, class U, class... Args&gt;
      constexpr T&amp; emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
    template&lt;std::size_t I, class... Args&gt;
      constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp; emplace(Args&amp;&amp;...);
    template&lt;std::size_t I, class U, class... Args&gt;
      constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
        emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

    // <a href="#rvariant.status">value status</a>
    constexpr bool valueless_by_exception() const noexcept;
    constexpr std::size_t index() const noexcept;

    // <a href="#rvariant.swap">swap</a>
    constexpr void swap(rvariant&amp;) noexcept(/* see below */);

    // <a href="#rvariant.visit">visitation</a>
    template&lt;class Self, class Visitor&gt;
      constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);
    template&lt;class R, class Self, class Visitor&gt;
      constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);
};

} // temp_ns</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.requirements"><a class="anchor" href="#rvariant.requirements"></a>Requirements</h3>
<div class="paragraph">
<p>Let <strong><em>rv</em></strong> be an instance of <code>rvariant&lt;Ts...&gt;</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong><em>rv</em></strong> follows all type traits of <code>std::variant</code>, unless otherwise noted.</p>
</li>
<li>
<p>All <code>Ts...</code> must satisfy all constraints on <code>std::variant</code>, unless otherwise noted.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also: spec of <a href="https://eel.is/c++draft/variant"><code>std::variant</code></a> and <a href="https://www.boost.org/doc/libs/develop/doc/html/variant/reference.html#variant.concepts"><code>boost::variant</code></a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.constructors"><a class="anchor" href="#rvariant.constructors"></a>Constructors</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr rvariant::rvariant() noexcept(/* see below */);<span class="candidate">// 1</span>
constexpr rvariant::rvariant(rvariant const&amp;);<span class="candidate">// 2</span>
constexpr rvariant::rvariant(rvariant&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 3</span>

template&lt;class T&gt;
constexpr rvariant(T&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 4</span>

template&lt;class T, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;...);<span class="candidate">// 5</span>

template&lt;class T, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);<span class="candidate">// 6</span>

template&lt;std::size_t I, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;...);<span class="candidate">// 7</span>

template&lt;std::size_t I, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);<span class="candidate">// 8</span>

/* extensions */

template&lt;class... Us&gt;
    requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&lt;Ts...&gt;&gt;)
constexpr rvariant(rvariant&lt;Us...&gt; const&amp; w);<span class="candidate">// 9</span>

template&lt;class... Us&gt;
    requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&lt;Ts...&gt;&gt;)
constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);<span class="candidate">// 10</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-8)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">9)</span> Flexible copy constructor. If <code>w</code> does not hold a value, initializes the <code>rvariant</code> to not hold a value. Otherwise, initializes the <code>rvariant</code> to hold the corresponding alternative as <code>w</code> and direct-initializes the contained value with <code><em>GET</em>&lt;j&gt;(w)</code>, where <code>j</code> is <code>w.index()</code> and <code><em>GET</em></code> is defined as per <a href="https://eel.is/c++draft/variant.get">[variant.get]</a>.</p>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>This constructor is defined as deleted unless <code><a href="#rvariant.xo.flexibility">subset-like</a>&lt;rvariant&lt;Ts...&gt;, rvariant&lt;Us...&gt;&gt;</code> and <code>std::is_copy_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> for all <em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us...</code>.</p>
</li>
<li>
<p>In case of duplicate alternative types, the corresponding index in <code>rvariant</code> shall be determined by the first occurrence of the same type in <code>Ts...</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">10)</span> Flexible move constructor. If <code>w</code> does not hold a value, initializes the <code>rvariant</code> to not hold a value. Otherwise, initializes the <code>rvariant</code> to hold the corresponding alternative as <code>w</code> and direct-initializes the contained value with <code><em>GET</em>&lt;j&gt;(std::move(w))</code>, where <code>j</code> is <code>w.index()</code> and <code><em>GET</em></code> is defined as per <a href="https://eel.is/c++draft/variant.get">[variant.get]</a>.</p>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>This constructor is defined as deleted unless <code><a href="#rvariant.xo.flexibility">subset-like</a>&lt;rvariant&lt;Ts...&gt;, rvariant&lt;Us...&gt;&gt;</code>.</p>
</li>
<li>
<p>The exception specification is equivalent to the logical <code>AND</code> of <code>std::is_nothrow_move_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> for all <em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us...</code>.</p>
</li>
<li>
<p>In case of duplicate alternative types, the corresponding index in <code>rvariant</code> shall be determined by the first occurrence of the same type in <code>Ts...</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Exceptions </dt>
<dd>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-8)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">9)</span> Throws any exception thrown by direct-initializing any type in <code>Us...</code>.</p>
</li>
<li>
<p><span class="candidate">10)</span> Throws any exception thrown by move-constructing any type in <code>Us...</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.destructor"><a class="anchor" href="#rvariant.destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr ~rvariant();<span class="candidate">// 1</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.dtor">[spec]</a></sup></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.assign"><a class="anchor" href="#rvariant.assign"></a>Assignment</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr rvariant&amp; operator=(rvariant const&amp;);<span class="candidate">// 1</span>
constexpr rvariant&amp; operator=(rvariant&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 2</span>

template&lt;class T&gt; constexpr rvariant&amp; operator=(T&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 3</span>

/* extensions */

template&lt;class... Us&gt;
    requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&lt;Ts...&gt;&gt;)
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp; w);<span class="candidate">// 4</span>

template&lt;class... Us&gt;
    requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&lt;Ts...&gt;&gt;)
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);<span class="candidate">// 5</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-3)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.assign">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">4)</span> Flexible copy assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO</p>
</li>
<li>
<p><span class="candidate">5)</span> Flexible move assignment operator. TODO TODO TODO TODO TODO TODO TODO TODO</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.mod"><a class="anchor" href="#rvariant.mod"></a>Modifiers</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class T, class... Args&gt;
constexpr T&amp; emplace(Args&amp;&amp;...);

template&lt;class T, class U, class... Args&gt;
constexpr T&amp; emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

template&lt;std::size_t I, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
    emplace(Args&amp;&amp;...);

template&lt;std::size_t I, class U, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
    emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.mod">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.status"><a class="anchor" href="#rvariant.status"></a>Value status</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.status">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.swap"><a class="anchor" href="#rvariant.swap"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr void swap(rvariant&amp;) noexcept(/* see below */);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.swap">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.visit"><a class="anchor" href="#rvariant.visit"></a>Visitation</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class Self, class Visitor&gt;
constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);

template&lt;class R, class Self, class Visitor&gt;
constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.visit">[spec]</a></sup></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.recursive"><a class="anchor" href="#rvariant.recursive"></a>Class template <code>recursive_wrapper</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;compare&gt;

namespace temp_ns {

template&lt;class T&gt;
class recursive_wrapper
{
public:

    // ...
    // TODO
    // ...

};

} // temp_ns</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="constructors"><a class="anchor" href="#constructors"></a>Constructors</h3>
<div class="paragraph">
<p>TODO TODO TODO TODO TODO TODO</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.pack"><a class="anchor" href="#rvariant.pack"></a>Pack manipulation and deduping</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Experimental feature proposal; need further consideration
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
struct pack_union;<span class="candidate">// 1</span>

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
struct pack_union_t = typename pack_union&lt;TT, A, B&gt;::type;

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
struct compact_alternative;<span class="candidate">// 2</span>

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
using compact_alternative_t = typename compact_alternative&lt;TT, A, B&gt;::type;

} // temp_ns</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Let <code>As</code> denote the pack of template parameters of <code>A</code> if <a href="#rvariant.xo.core"><code><em>is-specialization-of&lt;A, TT&gt;</em></code></a>, otherwise let <code>As</code> denote a pack of single type <code>A</code>. Let <code>Bs</code> denote likewise. <code>pack_union</code> defines the member type <code>::type</code> as <code>TT&lt;Ts...&gt;</code>, where <code>Ts...</code> is the union of <code>As...</code> and <code>Bs...</code>. The order of types shall be preserved.</p>
</li>
<li>
<p><span class="candidate">2)</span> Let <code>Ts</code> denote an imaginary pack of types where <code>TT&lt;Ts...&gt;</code> is the same type as <code>pack_union_t&lt;TT, A, B&gt;</code>. <code>compact_alternative</code> defines the member type <code>::type</code> as the first type in <code>Ts...</code> if <code>sizeof...(Ts) == 1</code>; otherwise, it is defined as <code>TT&lt;Ts...&gt;</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Notes on single-type variant</div>
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be <em>unwrapped</em> using <code>compact_alternative</code>. This is useful for resolving issues such as <a href="https://github.com/boostorg/spirit/issues/610">boostorg/spirit#610</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.io"><a class="anchor" href="#rvariant.io"></a>I/O</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.xo"><a class="anchor" href="#rvariant.xo"></a>Exposition-only utilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section demonstrates internal features used in the implementation.</p>
</div>
<div class="sect2">
<h3 id="rvariant.xo.flexibility"><a class="anchor" href="#rvariant.xo.flexibility"></a>Flexibility traits</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class T, class U&gt;
struct <em>subset_like</em> : std::false_type {}; // exposition-only

template&lt;
  template&lt;class...&gt; class TT, class... Ts,
  template&lt;class...&gt; class UU, class... Us
&gt;
struct <em>subset_like</em>&lt;TT&lt;Ts...&gt;, UU&lt;Us...&gt;&gt; : std::true_type {}; // exposition-only<span class="candidate">// 1</span>

template&lt;class T, class U&gt;
constexpr bool <em>subset-like</em> = <em>subset_like</em>::value; // exposition-only</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Constraints:</em></strong> For every type <code>U</code> in <code>Us...</code>, there exists at least one type <code>T</code> in <code>Ts...</code> such that <code>U</code> is the same type as <code>T</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.xo.core"><a class="anchor" href="#rvariant.xo.core"></a>Core type traits</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class T, template&lt;class...&gt; class TT&gt;
struct <em>is-ttp-specialization-of</em>; // exposition-only<span class="candidate">// 1</span>

template&lt;class T, template&lt;auto...&gt; class TT&gt;
struct <em>is-nttp-specialization-of</em>; // exposition-only<span class="candidate">// 2</span>

template&lt;class T, <em>any-ttp</em>&gt;
struct <em>is-specialization-of</em>; // exposition-only<span class="candidate">// 3</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-2)</span> Inherits <code>std::true_type</code> if and only if <code>T</code> is a specialization of <code>TT</code>; otherwise, <code>std::false_type</code>.</p>
</li>
<li>
<p><span class="candidate">3)</span> If <code><em>any-ttp</em></code> is a template template parameter that consists of NTTP, equivalent to <code><em>is-nttp-specialization-of</em></code>; otherwise, equivalent to <code><em>is-ttp-specialization-of</em></code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code><em>is-specialization-of</em></code> is currently unimplementable due to lack of language feature; it requires C++26 reflection for a straightforward resolution. For now, it can be worked around by a compound <code>requires</code> expression.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="additional-information" class="sect0"><a class="anchor" href="#additional-information"></a>Additional information</h1>
<div class="sect1">
<h2 id="benchmark"><a class="anchor" href="#benchmark"></a>Benchmark</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Non-recursive / Recursive</p>
</div>
<div class="paragraph">
<p>GCC / Clang / MSVC</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>