<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.22">
<meta name="author" content="Yaito Kakeyama, Nana Sakisaka">
<title>rvariant</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

body {
  font-size: 12.8px;
  font-family: DejaVuSans, 'DejaVu Sans', sans-serif;
  color: rgb(11, 11, 11);
}

h1, h2, p, td.content, span.alt, summary {
  letter-spacing: inherit;
}

p strong, td.content strong, div.footnote strong {
  letter-spacing: inherit;
}

.quoteblock .attribution cite, .verseblock .attribution cite {
  letter-spacing: inherit;
}

p, td.content {
  font-size: inherit;
}

a, .underline {
  text-decoration-skip-ink: none;
}

dt {
  font-size: 1.3em;
}

:where(th, td):has(.good) {
  background-color: rgb(202, 255, 255);
}

:where(th, td):has(.bad) {
  background-color: rgb(255, 213, 213);
}

table.params tr th, table.params tr td {
  padding: .2em .25em;
}

code {
  font-family: 'DejaVu Sans Mono', monospace;
  max-width: 800px;
}

:not(pre):not([class^=L]) > code {
  background: rgb(239, 239, 241);
  border-radius: 0;
}

:is(#fakeId, pre) code {
  position: relative;
}

:is(#fakeId, pre) code:has(.candidate) {
  padding-right: 4em;
}

code .candidate {
  display: inline-flex;
  position: absolute;
  right: 0;

  user-select: none;
  margin-right: 1em;
}

li p:has(+ .ulist) {
  margin-bottom: 0;
}

.candidate .hljs-comment {
  font-style: normal;
  font-weight: bold;
  color: #008000;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul {
  list-style-type: none;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  padding-left: 2rem;
  text-indent: -4.25rem;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  margin-bottom: 1em;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li :is(.paragraph, ul) {
  text-indent: 0;
}

.candidates .candidate {
  display: inline-block;
  width: 4rem;
  text-align: right;
  text-indent: 0;
  font-weight: bold;
}

.conum[data-value] {
  background: rgba(0, 0, 0, 0.6);
}

.listingblock:hover code[data-lang]::before {
  display: none;
}

.small-note {
  font-size: 0.9em;
  opacity: 0.8;
}

.scroll-x {
  overflow-x: auto;
}

#toc.toc2 > ul {
  font-size: inherit;
}

#toc.toc2 #toctitle {
  font-size: 1.375em;
}

#feature-overview ~ * code a {
  font-weight: bold;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>rvariant</h1>
<div class="details">
<span id="author" class="author">Yaito Kakeyama</span><br>
<span id="author2" class="author">Nana Sakisaka</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">rvariant</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#motivation">Motivation</a></li>
<li><a href="#goals">Project goals</a></li>
<li><a href="#comparison">Comparison of variant libraries</a></li>
<li><a href="#why-is-recursive-wrapper-needed-1">Why is recursive_wrapper needed?</a></li>
<li><a href="#why-is-recursive-wrapper-needed-2">Why can&#8217;t I just use std::unique_ptr instead of recursive_wrapper?</a></li>
</ul>
</li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel1">
<li><a href="#feature-cheat-sheet">Feature cheat sheet</a></li>
<li><a href="#rvariant.syn">Header &lt;temp_ns/rvariant.hpp&gt; synopsis</a></li>
<li><a href="#rvariant.rvariant">Class template <code>rvariant</code></a>
<ul class="sectlevel2">
<li><a href="#rvariant.general">General</a></li>
<li><a href="#rvariant.constructors">Constructors</a></li>
<li><a href="#rvariant.destructor">Destructor</a></li>
<li><a href="#rvariant.assign">Assignment</a></li>
<li><a href="#rvariant.mod">Modifiers</a></li>
<li><a href="#rvariant.status">Value status</a></li>
<li><a href="#rvariant.subset">Subset</a></li>
<li><a href="#rvariant.swap">Swap</a></li>
<li><a href="#rvariant.visit">Visitation</a></li>
<li><a href="#rvariant.hash">Hash support</a></li>
</ul>
</li>
<li><a href="#rvariant.helper"><code>rvariant</code> helper utilities</a>
<ul class="sectlevel2">
<li><a href="#rvariant.helper.flexibility">Flexibility traits</a></li>
</ul>
</li>
<li><a href="#rvariant.recursive">Class template <code>recursive_wrapper</code></a>
<ul class="sectlevel2">
<li><a href="#rvariant.recursive.general">General</a></li>
<li><a href="#rvariant.recursive.hash">Hash support</a></li>
</ul>
</li>
<li><a href="#rvariant.pack">Pack manipulation and deduping</a></li>
<li><a href="#rvariant.io">I/O</a></li>
<li><a href="#rvariant.xo">Exposition-only utilities</a>
<ul class="sectlevel2">
<li><a href="#rvariant.xo.pack">Pack utilities</a></li>
<li><a href="#rvariant.xo.core">Core type traits</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-information">Additional information</a>
<ul class="sectlevel1">
<li><a href="#benchmark">Benchmark</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>rvariant</code> is a variant library that supports recursive types. It is API-compatible with <code>std::variant</code> and includes Boost-style interfaces that act as proxies to the standard-compatible API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// A common pattern for representing recursive ASTs using recursive variants.
struct BinaryExpr; enum class Op;
using Expr = temp_ns::rvariant&lt;int, double, temp_ns::recursive_wrapper&lt;BinaryExpr&gt;&gt;;
struct BinaryExpr { Expr lhs, rhs; Op op; };</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="motivation"><a class="anchor" href="#motivation"></a>Motivation</h3>
<div class="paragraph">
<p>Since its introduction in 2004, <code>boost::variant</code> has been used for a wide range of type-safe union use cases.</p>
</div>
<div class="paragraph">
<p>Starting with C&#43;&#43;17, most of those can be replaced with <code>std::variant</code>, <em>except</em> for <strong>recursive types</strong>. As a result, many users of generic frameworks that inherently require recursive variants&#8212;&#8203;most notably Boost.Spirit&#8212;&#8203;have continued using <code>boost::variant</code>, despite its significant impact on compile times.</p>
</div>
<div class="paragraph">
<p>The compile-time slowness of <code>boost::variant</code> stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with <code>boost::variant</code>'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.</p>
</div>
<div class="paragraph">
<p>Until 2025, no one had managed to introduce a modern alternative into either Boost or the C&#43;&#43; standard. <code>rvariant</code> fills this gap with a new implementation that supports recursive types while remaining API-compatible with <code>std::variant</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="goals"><a class="anchor" href="#goals"></a>Project goals</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Provide a modern, efficient, and battle-tested recursive variant library</strong> to enable developers to avoid using Boost.Variant in new applications.</p>
</li>
<li>
<p><strong>Replace existing usages of Boost.Variant</strong> in established frameworks, especially Boost.Spirit.X3.</p>
</li>
<li>
<p><strong>Explore potential directions for future standardization,</strong> while gaining implementation experience with the renewed design.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="comparison"><a class="anchor" href="#comparison"></a>Comparison of variant libraries</h3>
<div class="openblock scroll-x">
<div class="content">
<table class="tableblock frame-ends grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code><strong>temp_ns::rvariant</strong></code></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant.html"><code><strong>std::variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/variant.html"><code><strong>Boost.Variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html"><code><strong>Boost.Variant2</strong></code></a></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Minimum C++ version</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;20</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11<br>
<span class="icon"><i class="fa fa-warning"></i></span> Mostly legacy code from 2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compilation speed</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">Very Slow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fast</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Interface for recursive types</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="good">Yes</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/boost/recursive_wrapper.html"><strong class="good">Yes</strong></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>May be valueless?</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html">Yes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty">No</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_never_valueless">No</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Exception safety</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="good">Strong exception safety</span><br>
<a href="https://www.boost.org/doc/libs/develop/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution">(Temporary heap backup)</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="good">Strong exception safety</span><br>
<a href="https://www.boost.org/doc/libs/develop/libs/variant2/doc/html/variant2.html#design_strong_exception_safety">(Double storage)</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Flexible construction<br>
<code>V&lt;A,B&gt; = V&lt;B,A&gt;</code><br>
<code>V&lt;A,B,C&gt; = V&lt;A,B&gt;</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="why-is-recursive-wrapper-needed-1"><a class="anchor" href="#why-is-recursive-wrapper-needed-1"></a>Why is recursive_wrapper needed?</h3>
<div class="paragraph">
<p>A variant class cannot determine its storage&#8217;s size when it contains incomplete types. Therefore, recursive alternatives always require a <strong>recursive wrapper class</strong> that holds the incomplete type by pointer and performs dynamic memory allocation on it.</p>
</div>
</div>
<div class="sect2">
<h3 id="why-is-recursive-wrapper-needed-2"><a class="anchor" href="#why-is-recursive-wrapper-needed-2"></a>Why can&#8217;t I just use std::unique_ptr instead of recursive_wrapper?</h3>
<div class="paragraph">
<p><em>Theoretically</em>, a recursive wrapper class can be designed independently, i.e. having no correlation to the variant class itself. So there&#8217;s no theoretical reason to prevent you from using <code>std::unique_ptr</code> with <code>std::variant</code>.</p>
</div>
<div class="paragraph">
<p>However, <strong>it is essential to have compatible interfaces in the variant class</strong>, because the lack of interfaces means that you must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>wrap</em> the actual type with the wrapper class every single time you modify variants, and</p>
</li>
<li>
<p><em>unwrap</em> the instances every single time you access the alternative returned by <code>get()</code> and <code>visit()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, the commonly seen advice like <em>"use std::unique_ptr if you want to hold recursive types in std::variant"</em> is a <em>hack</em> that basically does <strong>nothing</strong> except for just holding the wrapper instance. As said above, such unadapted wrappers introduce <em>intrusive</em> boilerplates that infect the application layer, which is undesirable in practice.</p>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0"><a class="anchor" href="#reference"></a>Reference</h1>
<div class="sect1">
<h2 id="feature-cheat-sheet"><a class="anchor" href="#feature-cheat-sheet"></a>Feature cheat sheet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.</p>
</div>
<h3 id="basic-features" class="discrete">Basic features</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">using A = int;
using B = double;
struct C {};

using AB  = temp_ns::<a href="#rvariant.rvariant">rvariant</a>&lt;A, B&gt;;
using BA  = temp_ns::rvariant&lt;B, A&gt;;
using ABC = temp_ns::rvariant&lt;A, B, C&gt;;

// <a href="#rvariant.constructors">constructor</a>
AB ab{42};

{
    AB local_ab{};
} // <a href="#rvariant.destructor">destructor</a>

ab<a href="#rvariant.mod">.emplace&lt;int&gt;(123)</a>;
ab<a href="#rvariant.mod">.emplace&lt;0&gt;(123)</a>;

// <a href="#rvariant.assign">assignment</a>
ab = AB{123};

// recursive types
{
    struct BinaryExpr;
    using Expr = temp_ns::rvariant&lt;A, B, C, temp_ns::<a href="#rvariant.recursive">recursive_wrapper</a>&lt;BinaryExpr&gt;&gt;;
    struct BinaryExpr { Expr lhs, rhs; };
}

A&amp; a = temp_ns::<a href="#rvariant.syn">get</a>&lt;0&gt;(ab);
A&amp; a = temp_ns::get&lt;A&gt;(ab);
C&amp; c = temp_ns::get&lt;C&gt;(ab);     // throws <a href="https://en.cppreference.com/w/cpp/utility/variant/bad_variant_access.html"><code>std::bad_variant_access</code></a>

A* a = temp_ns::<a href="#rvariant.syn">get_if</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get_if&lt;A&gt;(&amp;ab);
C* c = temp_ns::get_if&lt;C&gt;(&amp;ab); // <code>nullptr</code>

// compatibility with boost; same effect as <code>get_if</code>
A* a = temp_ns::<a href="#rvariant.syn">get</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get&lt;A&gt;(&amp;ab);
C* c = temp_ns::get&lt;C&gt;(&amp;ab);    // <code>nullptr</code>

<a href="#rvariant.syn">ab == ab</a>;
<a href="#rvariant.syn">ab &lt; ab</a>;
<a href="#rvariant.syn">ab &lt;=&gt; ab</a>; // <code>requires (<a href="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable">std::three_way_comparable</a>&lt;Ts&gt; &amp;&amp; ...)</code>

auto visitor = temp_ns::<a href="#rvariant.utility-todo">overloaded</a> {
    [](A const&amp; a) {},
    [](B const&amp; b) {},
};

ab<a href="#rvariant.visit">.visit(visitor)</a>;           // member visit
temp_ns::<a href="#rvariant.syn">visit</a>(visitor, ab); // function visit</code></pre>
</div>
</div>
<h3 id="advanced-features" class="discrete">Advanced features</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">{
    // <a href="#rvariant.constructors">flexible construction</a>
    AB ab{BA{}};   // unordered construction
    ABC abc{AB{}}; // subset construction

    // <a href="#rvariant.assign">flexible assignment</a>
    ab = BA{};     // unordered assignment
    abc = AB{};    // subset assignment
}

static_assert(temp_ns::<a href="#rvariant.syn">variant_size_v</a>&lt;AB&gt; == 2);
static_assert(std::same_as&lt;temp_ns::<a href="#rvariant.syn">variant_alternative_t</a>&lt;0, AB&gt;, A&gt;);
static_assert(temp_ns::<a href="#rvariant.syn">holds_alternative</a>&lt;A&gt;(ab));

static_assert(ab<a href="#rvariant.status">.index()</a> != <a href="https://en.cppreference.com/w/cpp/utility/variant/variant_npos">std::variant_npos</a>);
static_assert(!ab<a href="#rvariant.status">.valueless_by_exception()</a>);

{
    AB tmp;
    ab<a href="#rvariant.swap">.swap(tmp)</a>;
}
{
    using std::swap;
    AB tmp;
    <a href="#rvariant.syn">swap</a>(ab, tmp); // ADL
}

std::size_t _ = <a href="#rvariant.syn">std::hash&lt;AB&gt;{ab}</a>();
std::size_t _ = <a href="#rvariant.syn">hash_value(ab)</a>; // compatibility with boost

// <a href="#rvariant.io">I/O support</a>
{
    std::println("{}", AB{123});   // "123"
    std::cout &lt;&lt; AB{123} &lt;&lt; '\n';  // "123"

    // "type is A, value is 123" -- C&#43;&#43;26 reflection
    std::println("{:type is %t, value is %v}", AB{123}); // Note that %t prints <code>A</code>, not <code>int</code>

    std::println("{}", ABC{C{}});  // "C" -- C&#43;&#43;26 reflection
    std::cout &lt;&lt; ABC{C{}} &lt;&lt; '\n'; // "C" -- C&#43;&#43;26 reflection
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.syn"><a class="anchor" href="#rvariant.syn"></a>Header &lt;temp_ns/rvariant.hpp&gt; synopsis</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;compare&gt;
#include &lt;utility&gt; // for `std::in_place_type`, etc.
#include &lt;variant&gt; // for compatibility with `std::bad_variant_access`

namespace temp_ns {

// <a href="#rvariant.rvariant">class template <code>rvariant</code></a>
template&lt;class... Ts&gt;
class rvariant;

/* all features commented below defined as per <a href="https://eel.is/c++draft/variant">[variant]</a> */
    // variant_size, variant_size_v
    // variant_alternative, variant_alternative_v
    // get
    // get_if

    // operator==
    // operator!=
    // operator&lt;
    // operator&gt;
    // operator&lt;=
    // operator&gt;=
    // operator&lt;=&gt;

    // visit
    // swap

<a href="https://eel.is/c++draft/variant.syn">/* not defined; use the <code>std::</code> versions instead */</a>
    // variant_npos
    // monostate and monostate-related functionalities
    // bad_variant_access

/* extension */

template&lt;std::size_t I, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt;*) noexcept;       // delegates to `get_if`

template&lt;std::size_t I, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt; const*) noexcept; // delegates to `get_if`

template&lt;class T, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt;*) noexcept;       // delegates to `get_if`

template&lt;class T, class... Ts&gt;
  constexpr /* equivalent to standard */
    get(rvariant&lt;Ts...&gt; const*) noexcept; // delegates to `get_if`

// ...
// TODO: I/O
// ...

template&lt;class... Ts&gt;
/* constexpr */ std::size_t hash_value(rvariant&lt;Ts...&gt; const&amp; v);

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace std {

template&lt;class... Ts&gt; struct hash&lt;::temp_ns::rvariant&lt;Ts...&gt;&gt;;

} // std</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.rvariant"><a class="anchor" href="#rvariant.rvariant"></a>Class template <code>rvariant</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;class... Ts&gt;
class rvariant
{
public:
  // <a href="#rvariant.constructors">constructors</a>
  constexpr rvariant::rvariant() noexcept(/* see below */);
  constexpr rvariant::rvariant(rvariant const&amp;);
  constexpr rvariant::rvariant(rvariant&amp;&amp;) noexcept(/* see below */);

  template&lt;class T&gt;
    constexpr rvariant(T&amp;&amp;) noexcept(/* see below */);

  template&lt;class T, class... Args&gt;
    constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
  template&lt;class T, class U, class... Args&gt;
    constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class... Args&gt;
    constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class U, class... Args&gt;
    constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

  // <a href="#rvariant.constructors">flexible constructors</a>
  template&lt;class... Us&gt;
    constexpr rvariant(rvariant&lt;Us...&gt; const&amp; w);
  template&lt;class... Us&gt;
    constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);

  // <a href="#rvariant.destructor">destructor</a>
  constexpr ~rvariant();

  // <a href="#rvariant.assign">assignment</a>
  constexpr rvariant&amp; operator=(rvariant const&amp;);
  constexpr rvariant&amp; operator=(rvariant&amp;&amp;) noexcept(/* see below */);

  template&lt;class T&gt; constexpr rvariant&amp; operator=(T&amp;&amp;) noexcept(/* see below */);

  // <a href="#rvariant.assign">flexible assignment</a>
  template&lt;class... Us&gt;
    constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp;);
  template&lt;class... Us&gt;
    constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp;) noexcept(/* see below */);

  // <a href="#rvariant.mod">modifiers</a>
  template&lt;class T, class... Args&gt;
    constexpr T&amp; emplace(Args&amp;&amp;...);
  template&lt;class T, class U, class... Args&gt;
    constexpr T&amp; emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class... Args&gt;
    constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp; emplace(Args&amp;&amp;...);
  template&lt;std::size_t I, class U, class... Args&gt;
    constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
      emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

  // <a href="#rvariant.status">value status</a>
  constexpr bool valueless_by_exception() const noexcept;
  constexpr std::size_t index() const noexcept;

  // <a href="#rvariant.subset">subset</a>
  template&lt;class... Us&gt;
    constexpr rvariant&lt;Us...&gt; subset() const&amp; noexcept(/* see below */);
  template&lt;class... Us&gt;
    constexpr rvariant&lt;Us...&gt; subset() &amp;&amp; noexcept(/* see below */);

  // <a href="#rvariant.swap">swap</a>
  constexpr void swap(rvariant&amp;) noexcept(/* see below */);

  // <a href="#rvariant.visit">visitation</a>
  template&lt;class Self, class Visitor&gt;
    constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);
  template&lt;class R, class Self, class Visitor&gt;
    constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);
};

} // temp_ns</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.general"><a class="anchor" href="#rvariant.general"></a>General</h3>
<div class="ulist">
<ul>
<li>
<p><code>rvariant&lt;Ts...&gt;</code> follows all requirements of <code>std::variant</code>, unless otherwise noted.</p>
</li>
<li>
<p>All <code>Ts...</code> must satisfy all requirements on the corresponding parameter in <code>std::variant</code>, unless otherwise noted.</p>
</li>
<li>
<p><span class="underline">Underlined texts</span> indicate important characteristics of our extensions.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also: spec of <a href="https://eel.is/c++draft/variant"><code>std::variant</code></a> and <a href="https://www.boost.org/doc/libs/develop/doc/html/variant/reference.html#variant.concepts"><code>boost::variant</code></a>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.constructors"><a class="anchor" href="#rvariant.constructors"></a>Constructors</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr rvariant::rvariant() noexcept(/* see below */);<span class="candidate">// 1</span>
constexpr rvariant::rvariant(rvariant const&amp;);<span class="candidate">// 2</span>
constexpr rvariant::rvariant(rvariant&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 3</span>

template&lt;class T&gt;
constexpr rvariant(T&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 4</span>

template&lt;class T, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;...);<span class="candidate">// 5</span>

template&lt;class T, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);<span class="candidate">// 6</span>

template&lt;std::size_t I, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;...);<span class="candidate">// 7</span>

template&lt;std::size_t I, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);<span class="candidate">// 8</span>

/* extensions */

// Flexible copy constructor
template&lt;class... Us&gt;
constexpr rvariant(rvariant&lt;Us...&gt; const&amp; w);<span class="candidate">// 9</span>

// Flexible move constructor
template&lt;class... Us&gt;
constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(/* see below */);<span class="candidate">// 10</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-8)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">9)</span> <em>Flexible copy constructor</em>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>w</code> holds a value, initializes the <code>rvariant</code> to hold the <span class="underline">alternative corresponding to that of</span> <code>w</code> and direct-initializes the contained value with <code><em>GET</em>&lt;j&gt;(w)</code>, where <code>j</code> is <code>w.index()</code> and <code><em>GET</em></code> is defined as per <a href="https://eel.is/c++draft/variant.get">[variant.get]</a>. Otherwise, initializes the <code>rvariant</code> to not hold a value.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;This constructor is defined as deleted unless <span class="underline"><code><a href="#rvariant.helper.flexibility">subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code> and</span> <code>std::is_copy_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> for all <em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us...</code>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline">The corresponding alternative for <code>rvariant</code> is the one that has the same type as the alternative held by <code>w</code>. In case of duplicate alternatives, the alternative index in <code>rvariant</code> shall be determined by the first occurrence of the corresponding type in <code>Ts...</code>.</span></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">10)</span> <em>Flexible move constructor</em>.</p>
<div class="paragraph">
<p>Equivalent to #9, except that:</p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code><em>GET</em>&lt;j&gt;(w)</code> is replaced with <code><em>GET</em>&lt;j&gt;(std::move(w))</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;The exception specification is equivalent to the logical <code>AND</code> of <code>std::is_nothrow_move_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> for all <em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us...</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Exceptions </dt>
<dd>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-8)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">9)</span> Throws any exception thrown by direct-initializing any type in <code>Us...</code>.</p>
</li>
<li>
<p><span class="candidate">10)</span> Throws any exception thrown by move-constructing any type in <code>Us...</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.destructor"><a class="anchor" href="#rvariant.destructor"></a>Destructor</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr ~rvariant();<span class="candidate">// 1</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.dtor">[spec]</a></sup></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.assign"><a class="anchor" href="#rvariant.assign"></a>Assignment</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr rvariant&amp; operator=(rvariant const&amp;);<span class="candidate">// 1</span>
constexpr rvariant&amp; operator=(rvariant&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 2</span>

template&lt;class T&gt; constexpr rvariant&amp; operator=(T&amp;&amp;) noexcept(/* see below */);<span class="candidate">// 3</span>

/* extensions */

// Flexible copy assignment
template&lt;class... Us&gt;
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp; rhs);<span class="candidate">// 4</span>

// Flexible move assignment
template&lt;class... Us&gt;
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp; rhs) noexcept(/* see below */);<span class="candidate">// 5</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-3)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.assign">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">4)</span> <em>Flexible copy assignment operator</em>.</p>
<div class="paragraph">
<p>Let <em>j</em> be <code>rhs.index()</code>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong><em>Constraints:</em></strong> <span class="underline"><code><a href="#rvariant.helper.flexibility">subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>rhs</code> holds the <span class="underline">same alternative type</span> as <code>*this</code>, assigns the value contained in <code>rhs</code> to the value contained in <code>*this</code>. <span class="underline">(<em>Note:</em> <code>index()</code> is unchanged.)</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if either <code>std::is_nothrow_copy_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> or <code>std::is_nothrow_move_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>false</code>, equivalent to <code>emplace<span class="underline">&lt;<em>i</em>&gt;</span>(<em>GET</em><<em>j</em>>(rhs))</code> <span class="underline">where <em>i</em> is the corresponding index that is determined according to the rules defined in <a href="#rvariant.constructors">the flexible copy constructor</a></span>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, equivalent to <code>operator=(<span class="underline">rvariant&lt;Us...&gt;</span>(rhs))</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> If <code>rhs.valueless_by_exception()</code> is <code>true</code>, <code>index() == rhs.index()</code>; <span class="underline">otherwise, <code>*this</code> holds the same alternative type as <code>rhs</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>*this</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> This operator is defined as deleted unless <code>std::is_copy_construcible_v&lt;U<sub><em>j</em></sub>&gt;</code> &amp;&amp; <code>std::is_copy_assignable_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> for all <em>j</em>.</p>
</div>
</div>
</div>
</li>
<li>
<p><span class="candidate">5)</span> <em>Flexible move assignment operator</em>.</p>
<div class="paragraph">
<p>Let <em>j</em> be <code>rhs.index()</code>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p><strong><em>Constraints:</em></strong> <span class="underline"><code><a href="#rvariant.helper.flexibility">subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code> and</span> <code>std::is_move_constructible_v&lt;U<sub><em>j</em></sub>&gt; &amp;&amp; std::is_move_assignable_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> for all <em>j</em>.</p>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>rhs</code> holds the <span class="underline">same alternative type</span> as <code>*this</code>, assigns <code><em>GET</em><<em>j</em>>(std::move(rhs))</code> to the value contained in <code>*this</code>. <span class="underline">(<em>Note:</em> <code>index()</code> is unchanged.)</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, equivalent to <code>emplace<span class="underline">&lt;<em>i</em>&gt;</span>(<em>GET</em><<em>j</em>>(std::move(rhs)))</code> <span class="underline">where <em>i</em> is the corresponding index that is determined according to the rules defined in <a href="#rvariant.constructors">the flexible move constructor</a></span>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>*this</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> The exception specification is equivalent to <code>std::is_nothrow_move_constructible_v&lt;U<sub><em>j</em></sub>&gt; &amp;&amp; std::is_nothrow_move_assignable_v&lt;U<sub><em>j</em></sub>&gt;</code> for all <em>j</em>.</p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;If an exception is throw during the call to <code>U<sub><em>j</em></sub></code>'s move construction (with <em>j</em> being <code>rhs.index()</code>), the <code>rvariant</code> will hold no value.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;If an exception is thrown during the call to <code>U<sub><em>j</em></sub></code>'s move assignment, the state of the contained value is as defined by the exception safety guarantee of <code>U<sub><em>j</em></sub></code>'s move assignment; <code>index()</code> will be <span class="underline">the corresponding index determined according to the rules defined in <a href="#rvariant.constructors">the flexible move constructor</a>.</span></p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.mod"><a class="anchor" href="#rvariant.mod"></a>Modifiers</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class T, class... Args&gt;
constexpr T&amp; emplace(Args&amp;&amp;...);

template&lt;class T, class U, class... Args&gt;
constexpr T&amp; emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

template&lt;std::size_t I, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
  emplace(Args&amp;&amp;...);

template&lt;std::size_t I, class U, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Types...&gt;&gt;&amp;
  emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.mod">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.status"><a class="anchor" href="#rvariant.status"></a>Value status</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.status">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.subset"><a class="anchor" href="#rvariant.subset"></a>Subset</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class... Us&gt;
  requires std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&gt;
constexpr rvariant subset() const&amp; noexcept(std::is_nothrow_copy_constructible_v&lt;rvariant&gt;);<span class="candidate">// 1</span>

template&lt;class... Us&gt;
  requires std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&gt;
constexpr rvariant subset() &amp;&amp; noexcept(std::is_nothrow_move_constructible_v&lt;rvariant&gt;);<span class="candidate">// 2</span>

template&lt;class... Us&gt;
  requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&gt;)
constexpr rvariant&lt;Us...&gt; subset() const&amp; noexcept(/* see below */);<span class="candidate">// 3</span>

template&lt;class... Us&gt;
  requires (!std::same_as&lt;rvariant&lt;Us...&gt;, rvariant&gt;)
constexpr rvariant&lt;Us...&gt; subset() &amp;&amp; noexcept(/* see below */);<span class="candidate">// 4</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Returns <code>*this</code>.</p>
</li>
<li>
<p><span class="candidate">2)</span> Returns <code>std::move(*this)</code>.</p>
</li>
<li>
<p><span class="candidate">3)</span>
<strong><em>Mandates:</em></strong> <code>std::is_copy_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> is <code>true</code> for all <em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us...</code>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>*this</code> holds a value, returns an <code>rvariant&lt;Us...&gt;</code> object that holds the <span class="underline">alternative corresponding to that of</span> <code>*this</code>, with its contained value direct-initialized from <code><em>GET</em>&lt;<em>i</em>&gt;(*this)</code>, where <em>i</em> is <code>this-&gt;index()</code> and <code><em>GET</em></code> is defined as per <a href="https://eel.is/c++draft/variant.get">[variant.get]</a>. Otherwise, returns an <code>rvariant&lt;Us...&gt;</code> object that does not hold a value.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<span class="underline">This function does not participate in overload resolution unless <code><a href="#rvariant.helper.flexibility">subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>.</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;The exception specification is equivalent to the logical <code>AND</code> of <code>std::is_nothrow_copy_constructible_v&lt;U<sub><em>j</em></sub>&gt;</code> for all <em>j</em> <span class="underline">If <code><a href="#rvariant.helper.flexibility">equivalent_to</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>; otherwise, it is equivalent to <code>false</code></span>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline">The corresponding index on the returned <code>rvariant&lt;Us...&gt;</code> object shall be determined according to the rules defined in <a href="#rvariant.constructors">the flexible copy constructor</a>.</span></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">4)</span> Equivalent to the overload #3, except that:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code><em>GET</em>&lt;<em>i</em>&gt;(*this)</code> is replaced with <code><em>GET</em>&lt;<em>i</em>&gt;(std::move(*this))</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_copy_constructible_v</code> is replaced with <code>std::is_move_constructible_v</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_nothrow_copy_constructible_v</code> is replaced with <code>std::is_nothrow_move_constructible_v</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Exceptions </dt>
<dd>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Throws any exception thrown by copy-constructing any type in <code>Us...</code>.</p>
</li>
<li>
<p><span class="candidate">2)</span> Throws any exception thrown by move-constructing any type in <code>Us...</code>.</p>
</li>
<li>
<p><span class="candidate">3)</span> Throws <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a> if <code>*this</code> holds an alternative that is not contained in <code>Us...</code>; otherwise, throws any exception thrown by copy-constructing any type in <code>Us...</code>.</p>
</li>
<li>
<p><span class="candidate">4)</span> Throws <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a> if <code>*this</code> holds an alternative that is not contained in <code>Us...</code>; otherwise, throws any exception thrown by move-constructing any type in <code>Us...</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.swap"><a class="anchor" href="#rvariant.swap"></a>Swap</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">constexpr void swap(rvariant&amp;) noexcept(/* see below */);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.swap">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.visit"><a class="anchor" href="#rvariant.visit"></a>Visitation</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class Self, class Visitor&gt;
constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);

template&lt;class R, class Self, class Visitor&gt;
constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.visit">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.hash"><a class="anchor" href="#rvariant.hash"></a>Hash support</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;class... Ts&gt;
/* constexpr */ std::size_t hash_value(rvariant&lt;Ts...&gt; const&amp; v);<span class="candidate">// 1</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace std {

template&lt;class... Ts&gt;
struct hash&lt;::temp_ns::rvariant&lt;Ts...&gt;&gt;;<span class="candidate">// 2</span>

} // std</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Equivalent to <code>std::hash&lt;rvariant&lt;Ts...&gt;&gt;{}(v)</code>.</p>
<div class="paragraph">
<p><strong><em>Note:</em></strong> Although the standard for <code>std::hash&lt;std::variant&lt;Ts...&gt;&gt;</code> says it is not guaranteed to be <code>noexcept</code>, implementations tend to <em>strengthen</em> the noexcept specifier, as it being technically allowed by the specification.</p>
</div>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="candidate">2)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.hash">[spec]</a></sup></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.helper"><a class="anchor" href="#rvariant.helper"></a><code>rvariant</code> helper utilities</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="rvariant.helper.flexibility"><a class="anchor" href="#rvariant.helper.flexibility"></a>Flexibility traits</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class U, class T&gt;
struct is_subset_of : std::false_type {};

template&lt;
  template&lt;class...&gt; class UU, class... Us,
  template&lt;class...&gt; class TT, class... Ts
&gt;
struct is_subset_of&lt;UU&lt;Us...&gt;, TT&lt;Ts...&gt;&gt; : std::true_type {};<span class="candidate">// 1</span>

template&lt;class U, class T&gt;
constexpr bool is_subset_of_v = is_subset_of&lt;U, T&gt;::value;

template&lt;class U, class T&gt;
concept subset_of = is_subset_of_v&lt;U, T&gt;;

template&lt;class T, class U&gt;
concept equivalent_to = subset_of&lt;T, U&gt; &amp;&amp; subset_of&lt;U, T&gt;;</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Constraints:</em></strong> For every type <code>U</code> in <code>Us...</code>, there exists at least one type <code>T</code> in <code>Ts...</code> such that <code>U</code> is the same type as <code>T</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.recursive"><a class="anchor" href="#rvariant.recursive"></a>Class template <code>recursive_wrapper</code></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;compare&gt;
#include &lt;memory&gt;

namespace temp_ns {

template&lt;class T, class Allocator = std::allocator&lt;T&gt;&gt;
class recursive_wrapper
{
  // provides the same functionality as <a href="https://eel.is/c++draft/indirect">`std::indirect`</a>
};

// equivalent to the <a href="https://eel.is/c++draft/indirect">`std::indirect`</a> counterpart
template&lt;class Value&gt;
  recursive_wrapper(Value) -&gt; recursive_wrapper&lt;Value&gt;;

// equivalent to the <a href="https://eel.is/c++draft/indirect">`std::indirect`</a> counterpart
template&lt;class Allocator, class Value&gt;
  recursive_wrapper(std::allocator_arg_t, Allocator, Value)
    -&gt; recursive_wrapper&lt;
      Value,
      typename std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;Value&gt;
    &gt;;

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns::pmr {

template&lt;class T&gt;
using recursive_wrapper = ::temp_ns::recursive_wrapper&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;

} // temp_ns::pmr</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.recursive.general"><a class="anchor" href="#rvariant.recursive.general"></a>General</h3>
<div class="paragraph">
<p>The class template <code>temp_ns::recursive_wrapper</code> and relevant components in the namespace scope provide same functionality and have equivalent requirements as <code>std::indirect</code>, except that:</p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The class name is <code>recursive_wrapper</code>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::indirect</code> and <code>temp_ns::recursive_wrapper</code> are distinguishable in type level.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>temp_ns::recursive_wrapper</code> is designed to be <strong>NOT</strong> a type alias of <code>std::indirect</code> because such a declaration would not satisfy the characteristics described above.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although <code>std::indirect</code> is a C&#43;&#43;26 feature, <code>temp_ns::recursive_wrapper</code> can be used in C&#43;&#43;20.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.recursive.hash"><a class="anchor" href="#rvariant.recursive.hash"></a>Hash support</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;class T, class Allocator&gt;
/* constexpr */ std::size_t hash_value(recursive_wrapper&lt;T, Allocator&gt; const&amp; rw);<span class="candidate">// 1</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace std {

template&lt;class T, class Allocator&gt;
struct hash&lt;::temp_ns::recursive_wrapper&lt;T, Allocator&gt;&gt;;<span class="candidate">// 2</span>

} // std</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Equivalent to <code>std::hash&lt;recursive_wrapper&lt;T, Allocator&gt;&gt;{}(rw)</code>.</p>
<div class="paragraph">
<p><strong><em>Note:</em></strong> Although the standard for <code>std::hash&lt;std::indirect&lt;T, Allocator&gt;&gt;</code> says it is not guaranteed to be <code>noexcept</code>, implementations tend to <em>strengthen</em> the noexcept specifier, as it being technically allowed by the specification.</p>
</div>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="candidate">2)</span>
Equivalent to the <code>std::indirect</code> counterpart. <sup><a href="https://eel.is/c++draft/indirect.hash">[spec]</a></sup></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.pack"><a class="anchor" href="#rvariant.pack"></a>Pack manipulation and deduping</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">namespace temp_ns {

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
struct compact_alternative;<span class="candidate">// 1</span>

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
using compact_alternative_t = typename compact_alternative&lt;TT, A, B&gt;::type;

} // temp_ns</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Effectively concatenates contained types in <code>A</code> and <code>B</code>, then dedupes them. If the resulting type list consists of only a single type, the surrounding template is unwrapped.</p>
<div class="paragraph">
<p><em>Formally:</em>  Let <code>Ts</code> denote an imaginary pack of types where <code>TT&lt;Ts...&gt;</code> is the same type as <code><a href="#rvariant.xo.pack"><em>pack-union-t</em></a>&lt;TT, A, B&gt;</code>. <code>compact_alternative</code> defines the member type <code>::type</code> as the first type in <code>Ts...</code> if <code>sizeof...(Ts) == 1</code>; otherwise, it is defined as <code>TT&lt;Ts...&gt;</code>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Notes on single-type variant</div>
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be <em>unwrapped</em> using <code>compact_alternative</code>. This is useful for resolving issues such as <a href="https://github.com/boostorg/spirit/issues/610">boostorg/spirit#610</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.io"><a class="anchor" href="#rvariant.io"></a>I/O</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.xo"><a class="anchor" href="#rvariant.xo"></a>Exposition-only utilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section demonstrates internal features used in the implementation.</p>
</div>
<div class="sect2">
<h3 id="rvariant.xo.pack"><a class="anchor" href="#rvariant.xo.pack"></a>Pack utilities</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
using <em>pack-union-t</em> = /* see below */; // exposition-only<span class="candidate">// 1</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span> Let <code>As</code> denote the pack of template parameters of <code>A</code> if <a href="#rvariant.xo.core"><code><em>is-specialization-of&lt;A, TT&gt;</em></code></a>, otherwise let <code>As</code> denote a pack of single type <code>A</code>. Let <code>Bs</code> denote likewise. <code><em>pack-union-t</em></code> is <code>TT&lt;Ts...&gt;</code>, where <code>Ts...</code> is the set union of <code>As...</code> and <code>Bs...</code> expanded from left to right. For duplicate types, the first occurrence shall remain in <code>Ts...</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.xo.core"><a class="anchor" href="#rvariant.xo.core"></a>Core type traits</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">template&lt;class T, template&lt;class...&gt; class TT&gt;
struct <em>is-ttp-specialization-of</em>; // exposition-only<span class="candidate">// 1</span>

template&lt;class T, template&lt;auto...&gt; class TT&gt;
struct <em>is-nttp-specialization-of</em>; // exposition-only<span class="candidate">// 2</span>

template&lt;class T, <em>any-ttp</em>&gt;
struct <em>is-specialization-of</em>; // exposition-only<span class="candidate">// 3</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-2)</span> Inherits <code>std::true_type</code> if and only if <code>T</code> is a specialization of <code>TT</code>; otherwise, inherits <code>std::false_type</code>.</p>
</li>
<li>
<p><span class="candidate">3)</span> If <code><em>any-ttp</em></code> is a template template parameter that consists of NTTP, equivalent to <code><em>is-nttp-specialization-of</em></code>; otherwise, equivalent to <code><em>is-ttp-specialization-of</em></code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code><em>is-specialization-of</em></code> requires C&#43;&#43;26 reflection for a straightforward resolution. For older versions, it can be worked around by a compound <code>requires</code> expression.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="additional-information" class="sect0"><a class="anchor" href="#additional-information"></a>Additional information</h1>
<div class="sect1">
<h2 id="benchmark"><a class="anchor" href="#benchmark"></a>Benchmark</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Non-recursive / Recursive</p>
</div>
<div class="paragraph">
<p>GCC / Clang / MSVC</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>