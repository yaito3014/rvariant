<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<meta name="author" content="Yaito Kakeyama, Nana Sakisaka">
<title>rvariant</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<!--
  Copyright 2025 Nana Sakisaka
  Distributed under the Boost Software License, Version 1.0.
  https://www.boost.org/LICENSE_1_0.txt
-->
<link rel="license" href="https://www.boost.org/LICENSE_1_0.txt" title="Boost Software License, Version 1.0">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

body {
  font-size: 12.8px;
  font-family: DejaVuSans, 'DejaVu Sans', sans-serif;
  color: rgb(11, 11, 11);
}

h1, h2, h3, h4, h5, h6 {
  overflow: hidden;
  line-height: 1.3;
}

h1, h2, p, td.content, span.alt, summary {
  letter-spacing: inherit;
}

h1 > a {
  margin-left: 0.75rem;
}
h1 > a, h1 > a > span {
  display: inline-flex;
}

p strong, td.content strong, div.footnote strong {
  letter-spacing: inherit;
}

.quoteblock .attribution cite, .verseblock .attribution cite {
  letter-spacing: inherit;
}

p, td.content {
  font-size: inherit;
}

a {
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

a, .underline {
  text-decoration-skip-ink: none;
}

a code {
  color: inherit;
}

:is(a code, code a) .hljs-comment {
  color: inherit;
}

dt {
  font-size: 1.3em;
}

:where(th, td):has(.good) {
  background-color: rgb(202, 255, 255);
}

:where(th, td):has(.bad) {
  background-color: rgb(255, 213, 213);
}

table.params tr th, table.params tr td {
  padding: .2em .25em;
}

code {
  font-family: 'DejaVu Sans Mono', monospace;
  max-width: 800px;
}

:not(pre):not([class^=L]) > code {
  background: rgb(239, 239, 241);
  border-radius: 0;
}

.hljs {
  background: unset;
}

pre code.hljs {
  padding: 0;
}

.listingblock:hover code[data-lang]::before {
  display: none;
}

:is(#fakeId, pre) code {
  position: relative;
}

:is(#fakeId, pre) code:has(.candidate) {
  padding-right: 4em;
}

code .candidate {
  display: inline-flex;
  position: absolute;
  right: 0;

  user-select: none;
  margin-right: 1em;
}

li p:has(+ .ulist) {
  margin-bottom: 0;
}

.slug {
  float: right;
  margin-left: .25em;
}

.slug a {
  text-decoration: none;
  font-size: 1rem;
  font-family: "Noto Serif", serif;
}

#toc .slug {
  display: none;
}

.candidate .hljs-comment {
  font-style: normal;
  font-weight: bold;
  color: #008000;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul {
  list-style-type: none;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  padding-left: 2rem;
  text-indent: -4.25rem;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li {
  margin-bottom: 1em;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li :is(.paragraph, ul) {
  text-indent: 0;
}

:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li > p:has(+:is(.openblock, .ulist)),
:is(.candidates > .content > .ulist, .candidates.ulist) > ul > li > .paragraph:has(+:is(.openblock, .ulist)) > p {
  margin-bottom: 0.25em;
}

.sect2 > p:has(+:is(.openblock, .ulist)),
.sect2 > .paragraph:has(+:is(.openblock, .ulist)) > p {
  margin-bottom: 1em;
}

:where(.sectionbody, .sect1, .sect2, .sect3, .sect4) > .ulist:not(.candidates) {
  margin-left: 1em;
}

.candidates .candidate {
  display: inline-block;
  width: 4rem;
  text-align: right;
  text-indent: 0;
  font-weight: bold;
  margin-left: 0;
}

.conum[data-value] {
  background: rgba(0, 0, 0, 0.6);
}

.see-below, .exposition-only {
  font-style: italic;
  font-weight: normal;
  color: rgb(129, 199, 129);
}

.small-note {
  font-size: 0.9em;
  opacity: 0.8;
}

.scroll-x {
  overflow-x: auto;
}

#toc.toc2 > ul {
  font-size: inherit;
}

#toc.toc2 #toctitle {
  font-size: 1.375em;
}

.benchmark > .content {
  overflow-x: auto;
}

.benchmark > .content > iframe {
  width: 666px;
  height: 400px;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/cpp.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // https://github.com/highlightjs/highlight.js/issues/2889
  var mergeHTMLPlugin = (function () {
    'use strict';

    var originalStream;

    /**
     * @param {string} value
     * @returns {string}
     */
    function escapeHTML(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#x27;');
    }

    /* plugin itself */

    /** @type {HLJSPlugin} */
    const mergeHTMLPlugin = {
      // preserve the original HTML token stream
      "before:highlightElement": ({ el }) => {
        originalStream = nodeStream(el);
      },
      // merge it afterwards with the highlighted token stream
      "after:highlightElement": ({ el, result, text }) => {
        if (!originalStream.length) return;

        const resultNode = document.createElement('div');
        resultNode.innerHTML = result.value;
        result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
        el.innerHTML = result.value;
      }
    };

    /* Stream merging support functions */

    /**
     * @typedef Event
     * @property {'start'|'stop'} event
     * @property {number} offset
     * @property {Node} node
     */

    /**
     * @param {Node} node
     */
    function tag(node) {
      return node.nodeName.toLowerCase();
    }

    /**
     * @param {Node} node
     */
    function nodeStream(node) {
      /** @type Event[] */
      const result = [];
      (function _nodeStream(node, offset) {
        for (let child = node.firstChild; child; child = child.nextSibling) {
          if (child.nodeType === 3) {
            offset += child.nodeValue.length;
          } else if (child.nodeType === 1) {
            result.push({
              event: 'start',
              offset: offset,
              node: child
            });
            offset = _nodeStream(child, offset);
            // Prevent void elements from having an end tag that would actually
            // double them in the output. There are more void elements in HTML
            // but we list only those realistically expected in code display.
            if (!tag(child).match(/br|hr|img|input/)) {
              result.push({
                event: 'stop',
                offset: offset,
                node: child
              });
            }
          }
        }
        return offset;
      })(node, 0);
      return result;
    }

    /**
     * @param {any} original - the original stream
     * @param {any} highlighted - stream of the highlighted source
     * @param {string} value - the original source itself
     */
    function mergeStreams(original, highlighted, value) {
      let processed = 0;
      let result = '';
      const nodeStack = [];

      function selectStream() {
        if (!original.length || !highlighted.length) {
          return original.length ? original : highlighted;
        }
        if (original[0].offset !== highlighted[0].offset) {
          return (original[0].offset < highlighted[0].offset) ? original : highlighted;
        }

        /*
        To avoid starting the stream just before it should stop the order is
        ensured that original always starts first and closes last:

        if (event1 == 'start' && event2 == 'start')
          return original;
        if (event1 == 'start' && event2 == 'stop')
          return highlighted;
        if (event1 == 'stop' && event2 == 'start')
          return original;
        if (event1 == 'stop' && event2 == 'stop')
          return highlighted;

        ... which is collapsed to:
        */
        return highlighted[0].event === 'start' ? original : highlighted;
      }

      /**
       * @param {Node} node
       */
      function open(node) {
        /** @param {Attr} attr */
        function attributeString(attr) {
          return ' ' + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
        }
        // @ts-ignore
        result += '<' + tag(node) + [].map.call(node.attributes, attributeString).join('') + '>';
      }

      /**
       * @param {Node} node
       */
      function close(node) {
        result += '</' + tag(node) + '>';
      }

      /**
       * @param {Event} event
       */
      function render(event) {
        (event.event === 'start' ? open : close)(event.node);
      }

      while (original.length || highlighted.length) {
        let stream = selectStream();
        result += escapeHTML(value.substring(processed, stream[0].offset));
        processed = stream[0].offset;
        if (stream === original) {
          /*
          On any opening or closing tag of the original markup we first close
          the entire highlighted node stack, then render the original tag along
          with all the following original tags at the same offset and then
          reopen all the tags on the highlighted stack.
          */
          nodeStack.reverse().forEach(close);
          do {
            render(stream.splice(0, 1)[0]);
            stream = selectStream();
          } while (stream === original && stream.length && stream[0].offset === processed);
          nodeStack.reverse().forEach(open);
        } else {
          if (stream[0].event === 'start') {
            nodeStack.push(stream[0].node);
          } else {
            nodeStack.pop();
          }
          render(stream.splice(0, 1)[0]);
        }
      }
      return result + escapeHTML(value.substr(processed));
    }

    return mergeHTMLPlugin;
  }());

  hljs.addPlugin(mergeHTMLPlugin);
  hljs.configure({
    ignoreUnescapedHTML: true,
  });
  document.querySelectorAll('pre.highlight > code[data-lang]').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>rvariant<a href="https://github.com/yaito3014/rvariant" target="_blank" rel="noopener"><span class="image"><img src="https://img.shields.io/badge/GitHub-rvariant-purple?logo=github" alt="GitHub"></span></a></h1>
<div class="details">
<span id="author" class="author">Yaito Kakeyama</span><br>
<span id="author2" class="author">Nana Sakisaka</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">rvariant</div>
<ul class="sectlevel1">
<li><a href="#introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#motivation">Motivation</a></li>
<li><a href="#goals">Project Goals</a></li>
<li><a href="#comparison">Comparison of Variant Libraries</a></li>
</ul>
</li>
<li><a href="#rationale">Rationale</a>
<ul class="sectlevel2">
<li><a href="#why-is-recursive-wrapper-needed-1">Why is recursive_wrapper needed?</a></li>
<li><a href="#why-is-recursive-wrapper-needed-2">Why can&#8217;t I just use std::unique_ptr instead of recursive_wrapper?</a></li>
<li><a href="#why-is-rvariant-not-a-wrapper-of-std">Why can&#8217;t rvariant be a thin wrapper around std::variant?</a></li>
<li><a href="#why-is-rvariant-proposed-to-boost-1">Why is rvariant being proposed to Boost?</a></li>
<li><a href="#why-is-rvariant-proposed-to-boost-2">Why can&#8217;t rvariant be submitted directly to the C++ Standards Committee?</a></li>
<li><a href="#recursive-variants-in-general">Are recursive variants useful in general-purpose code?</a></li>
</ul>
</li>
<li><a href="#feature-cheat-sheet">Feature Cheat Sheet</a>
<ul class="sectlevel1">
<li><a href="#basic-features">Basic Features</a></li>
<li><a href="#advanced-features">Advanced Features</a></li>
</ul>
</li>
<li><a href="#rvariant">Reference <span class="slug">[rvariant]</span></a>
<ul class="sectlevel1">
<li><a href="#rvariant.general">General <span class="slug">[rvariant.general]</span></a></li>
<li><a href="#rvariant.syn">Header &lt;temp_ns/rvariant.hpp&gt; synopsis <span class="slug">[rvariant.syn]</span></a></li>
<li><a href="#rvariant.rvariant">Class template <code>rvariant</code> <span class="slug">[rvariant.rvariant]</span></a>
<ul class="sectlevel2">
<li><a href="#rvariant.rvariant.general">General <span class="slug">[rvariant.rvariant.general]</span></a></li>
<li><a href="#rvariant.ctor">Constructors <span class="slug">[rvariant.ctor]</span></a></li>
<li><a href="#rvariant.dtor">Destructor <span class="slug">[rvariant.dtor]</span></a></li>
<li><a href="#rvariant.assign">Assignment <span class="slug">[rvariant.assign]</span></a></li>
<li><a href="#rvariant.mod">Modifiers <span class="slug">[rvariant.mod]</span></a></li>
<li><a href="#rvariant.status">Value status <span class="slug">[rvariant.status]</span></a></li>
<li><a href="#rvariant.subset">Subset <span class="slug">[rvariant.subset]</span></a></li>
<li><a href="#rvariant.swap">Swap <span class="slug">[rvariant.swap]</span></a></li>
</ul>
</li>
<li><a href="#rvariant.helper"><code>rvariant</code> helper classes <span class="slug">[rvariant.helper]</span></a></li>
<li><a href="#rvariant.flex">Flexibility traits <span class="slug">[rvariant.flex]</span></a></li>
<li><a href="#rvariant.get">Value access <span class="slug">[rvariant.get]</span></a></li>
<li><a href="#rvariant.visit">Visitation <span class="slug">[rvariant.visit]</span></a></li>
<li><a href="#rvariant.hash">Hash support <span class="slug">[rvariant.hash]</span></a></li>
<li><a href="#rvariant.io">I/O <span class="slug">[rvariant.io]</span></a>
<ul class="sectlevel2">
<li><a href="#rvariant.io.ostream"><code>operator&lt;&lt;</code> support</a></li>
<li><a href="#rvariant.io.format"><code>std::formatter</code> support</a></li>
</ul>
</li>
<li><a href="#rvariant.recursive">Class template <code>recursive_wrapper</code> <span class="slug">[rvariant.recursive]</span></a>
<ul class="sectlevel2">
<li><a href="#rvariant.recursive.general">General <span class="slug">[rvariant.recursive.general]</span></a></li>
<li><a href="#rvariant.recursive.ctor">Constructors</a></li>
</ul>
</li>
<li><a href="#rvariant.recursive.helper"><code>recursive_wrapper</code> helper classes <span class="slug">[rvariant.recursive.helper]</span></a></li>
<li><a href="#rvariant.pack">Pack manipulation and deduping <span class="slug">[rvariant.pack]</span></a></li>
<li><a href="#rvariant.xo">Exposition-only utilities <span class="slug">[rvariant.xo]</span></a>
<ul class="sectlevel2">
<li><a href="#rvariant.xo.pack">Pack utilities <span class="slug">[rvariant.xo.pack]</span></a></li>
<li><a href="#rvariant.xo.core">Core type traits <span class="slug">[rvariant.xo.core]</span></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#additional-information">Additional Information</a>
<ul class="sectlevel1">
<li><a href="#benchmark">Benchmark</a></li>
<li><a href="#about">About the Authors</a></li>
<li><a href="#license">License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><code>rvariant</code> is a variant library that supports recursive types. It is API-compatible with <code>std::variant</code> and includes Boost-style interfaces that act as proxies to the standard-compatible API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// A common pattern for representing recursive ASTs using recursive variants.
struct BinaryExpr;
using Expr = temp_ns::<a href="#rvariant.rvariant">rvariant</a>&lt;int, double, temp_ns::<a href="#rvariant.recursive">recursive_wrapper</a>&lt;BinaryExpr&gt;&gt;;
enum class Op;
struct BinaryExpr { Expr lhs, rhs; Op op{}; };

Expr expr{BinaryExpr{Expr{42}, Expr{3.14}}};
expr.visit(temp_ns::overloaded{
    [](int const&amp;) { /* ... */ },
    [](double const&amp;) { /* ... */ },
    [](BinaryExpr const&amp;) { /* ... */ },
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This library is intended for future submission to the Boost Libraries. Until then, the namespace is documented as <code>temp_ns</code> to indicate that the name is not yet stable. The current implementation temporarily uses the namespace <code>yk</code>, which originates from the prototype codebase.
</td>
</tr>
</table>
</div>
<h3 id="supported-environments" class="discrete">Supported Environments</h3>
<div class="ulist">
<ul>
<li>
<p>GCC 14</p>
</li>
<li>
<p>Clang 21-22 (libc++)</p>
</li>
<li>
<p>MSVC (2022)</p>
</li>
<li>
<p>C&#43;&#43;23 and C&#43;&#43;26</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="motivation"><a class="anchor" href="#motivation"></a>Motivation</h3>
<div class="paragraph">
<p>Since its introduction in 2004, <code>boost::variant</code> has been used for a wide range of type-safe union use cases.</p>
</div>
<div class="paragraph">
<p>Starting with C&#43;&#43;17, most of those can be replaced with <code>std::variant</code>, <em>except</em> for <strong>recursive types</strong>. As a result, many users of generic frameworks that require recursive variants&#8212;&#8203;most notably Boost.Spirit&#8212;&#8203;have continued using <code>boost::variant</code>, despite its significant impact on compile times.</p>
</div>
<div class="paragraph">
<p>The compile-time slowness of <code>boost::variant</code> stems from long-standing technical debt: it relies heavily on preprocessor magic in Boost.MPL. This wizardry is so tightly coupled with <code>boost::variant</code>'s internals that any attempt to modernize it would be unrealistic; it would effectively require a complete rewrite.</p>
</div>
<div class="paragraph">
<p>Until 2025, no one had managed to introduce a modern alternative into either Boost or the C&#43;&#43; standard. <code>rvariant</code> fills this gap with a new implementation that supports recursive types while remaining API-compatible with <code>std::variant</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="goals"><a class="anchor" href="#goals"></a>Project Goals</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Provide a modern, efficient, and battle-tested recursive variant library</strong> to enable developers to avoid using Boost.Variant in new applications.</p>
</li>
<li>
<p><strong>Replace existing usages of Boost.Variant</strong> in established frameworks, especially Boost.Spirit.X3.</p>
</li>
<li>
<p><strong>Explore potential directions for future standardization,</strong> while gaining implementation experience with the modernized design.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="comparison"><a class="anchor" href="#comparison"></a>Comparison of Variant Libraries</h3>
<div class="openblock scroll-x">
<div class="content">
<table class="tableblock frame-ends grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code><strong>rvariant</strong></code></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant.html"><code><strong>std::variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant.html"><code><strong>Boost.Variant</strong></code></a></p></th>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/1_88_0/libs/variant2/doc/html/variant2.html"><code><strong>Boost.Variant2</strong></code></a></p></th>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Minimum C++ version</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;17</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11<br>
<span class="icon"><i class="fa fa-warning"></i></span> Mostly legacy code from 2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C&#43;&#43;11</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compilation speed</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">Very Slow</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Average</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Interface for recursive types</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="good">Yes</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant/tutorial.html#variant.tutorial.recursive"><strong class="good">Yes</strong></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>May be valueless?</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception.html">Yes</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant/design.html#variant.design.never-empty">No</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.boost.org/doc/libs/1_88_0/libs/variant2/doc/html/variant2.html#design_never_valueless">No</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Exception safety</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic exception safety</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strong exception safety<br>
<a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant/design.html#variant.design.never-empty.heap-backup-solution">(Temporary heap backup)</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Strong exception safety<br>
<a href="https://www.boost.org/doc/libs/1_88_0/libs/variant2/doc/html/variant2.html#design_strong_exception_safety">(Double storage)</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Flexible construction<br>
<code>V&lt;A,B&gt; = V&lt;B,A&gt;</code><br>
<code>V&lt;A,B,C&gt; = V&lt;A,B&gt;</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong class="bad">No</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rationale"><a class="anchor" href="#rationale"></a>Rationale</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="why-is-recursive-wrapper-needed-1"><a class="anchor" href="#why-is-recursive-wrapper-needed-1"></a>Why is recursive_wrapper needed?</h3>
<div class="paragraph">
<p>A recursive type is effectively an incomplete type at the point of its initial definition. However, a <code>std</code>-style variant class requires all alternative types to be complete, since the storage size must be determined at compile time. As a result, recursive alternatives must be wrapped in a <strong>recursive wrapper class</strong>, which holds the incomplete type via a pointer and manages it through dynamic memory allocation.</p>
</div>
</div>
<div class="sect2">
<h3 id="why-is-recursive-wrapper-needed-2"><a class="anchor" href="#why-is-recursive-wrapper-needed-2"></a>Why can&#8217;t I just use std::unique_ptr instead of recursive_wrapper?</h3>
<div class="paragraph">
<p><em>Theoretically</em>, a recursive wrapper class can be designed independently, i.e. having no correlation to the variant class itself. So there&#8217;s no theoretical reason to prevent you from using <code>std::unique_ptr</code> with <code>std::variant</code>.</p>
</div>
<div class="paragraph">
<p>However, <strong>it is essential to have compatible interfaces in the variant class</strong>, because the lack of interfaces means that you must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>wrap</em> the actual type with the wrapper class every time you modify variants, and</p>
</li>
<li>
<p><em>unwrap</em> the instance every time you access an alternative with <code>get()</code> or <code>visit()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In other words, the commonly seen advice like <em>"use std::unique_ptr if you want to hold recursive types in std::variant"</em> is a <em>hack</em> that basically does <strong>nothing</strong> except for just holding the wrapper instance. As said above, such unadapted wrappers introduce <em>intrusive</em> boilerplates that spreads to the application layer, which is undesirable in practice.</p>
</div>
</div>
<div class="sect2">
<h3 id="why-is-rvariant-not-a-wrapper-of-std"><a class="anchor" href="#why-is-rvariant-not-a-wrapper-of-std"></a>Why can&#8217;t rvariant be a thin wrapper around std::variant?</h3>
<div class="paragraph">
<p><code>rvariant</code> is designed to be a strict superset of <code>std::variant</code>, not just to act as a third-party drop-in replacement.</p>
</div>
<div class="paragraph">
<p>If <code>rvariant</code> is specified correctly, it has the potential to become the <strong>only variant library in the C++ standard</strong> capable of handling <em>both</em> recursive and non-recursive types transparently. However, if it is designed merely as a thin wrapper around <code>std::variant</code> (e.g. inheritance or composition), such a specification could never be standardized.</p>
</div>
<div class="paragraph">
<p>For this purpose, the documentation of <code>rvariant</code> is presented in a diff-based format that mirrors <code>std::variant</code>, with key characteristics marked using <span class="underline">underlines</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="why-is-rvariant-proposed-to-boost-1"><a class="anchor" href="#why-is-rvariant-proposed-to-boost-1"></a>Why is rvariant being proposed to Boost?</h3>
<div class="paragraph">
<p>One of the co-authors of <code>rvariant</code>, Nana Sakisaka, has been using Boost.Spirit for over 15 years and was endorsed as its maintainer in May 2025. <strong>Modernizing recursive variant support</strong> is a fundamental part of upgrading the Boost.Spirit.X3 codebase, and has become a main focus of ongoing maintenance efforts.</p>
</div>
<div class="paragraph">
<p>Although Boost.Spirit.X3 has a <a href="https://www.boost.org/doc/libs/1_88_0/libs/spirit/doc/x3/html/spirit_x3/tutorials/rexpr.html">somewhat updated counterpart</a>, it was never designed around a formal specification and still retains <a href="https://github.com/boostorg/spirit/blob/328d940c372367a8d76a48ed956e870b56738ce9/include/boost/spirit/home/x3/support/ast/variant.hpp#L131">legacy implementation details</a> from earlier stages of development.</p>
</div>
<div class="paragraph">
<p>As such, the initial version of <code>rvariant</code> was developed as an internal replacement within Boost.Spirit, as a sub-component with no external exposure. However, before a PR was even submitted, it became clear that the design had potential value beyond Spirit. This prompted a complete redesign into a standalone superset of <code>std::variant</code>, followed by preparation for formal Boost review.</p>
</div>
</div>
<div class="sect2">
<h3 id="why-is-rvariant-proposed-to-boost-2"><a class="anchor" href="#why-is-rvariant-proposed-to-boost-2"></a>Why can&#8217;t rvariant be submitted directly to the C++ Standards Committee?</h3>
<div class="paragraph">
<p>Historically, <strong>the concept of recursive variants in C&#43;&#43; has been closely tied to <a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant/tutorial.html#variant.tutorial.recursive">Boost.Variant</a> and <a href="https://www.boost.org/doc/libs/1_88_0/libs/spirit/doc/html/spirit/qi/tutorials/mini_xml___asts_.html#spirit.qi.tutorials.mini_xml___asts_.the_structures">Boost.Spirit.Qi</a></strong>. It has been investigated, implemented, and used across Boost Libraries and by end users for <em>decades</em>. For this reason, we believe it&#8217;s best to first gather feedback from the Boost community.</p>
</div>
<div class="paragraph">
<p>Moreover, we expect the working group to seek implementation experience, which inevitably involves the current state of Boost.Variant and related components. Submitting <code>rvariant</code> independently would likely result in making the process unnecessarily time-consuming.</p>
</div>
</div>
<div class="sect2">
<h3 id="recursive-variants-in-general"><a class="anchor" href="#recursive-variants-in-general"></a>Are recursive variants useful in general-purpose code?</h3>
<div class="paragraph">
<p>Boost.Spirit is just one example of a parser combinator library. In practice, <em>any application that constructs statically typed recursive data structures</em> can benefit from a recursive variant class. Furthermore, with the arrival of C&#43;&#43;26 reflection, such data structures are likely to become even more common.</p>
</div>
<div class="paragraph">
<p>A proper solution to these challenges requires a fully-featured library, not just a value-semantic wrapper that happens to work for minimal use cases. We hope this work can serve as a foundation for broader discussion about recursive variants in Boost and beyond.</p>
</div>
</div>
</div>
</div>
<h1 id="feature-cheat-sheet" class="sect0"><a class="anchor" href="#feature-cheat-sheet"></a>Feature Cheat Sheet</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>This section shows the pseudo-code for all features in this library. You can click on the links to jump to the corresponding reference.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basic-features"><a class="anchor" href="#basic-features"></a>Basic Features</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using A = int;
using B = double;
struct C {};

using AB  = temp_ns::<a href="#rvariant.rvariant">rvariant</a>&lt;A, B&gt;;
using BA  = temp_ns::rvariant&lt;B, A&gt;;
using ABC = temp_ns::rvariant&lt;A, B, C&gt;;

// <a href="#rvariant.ctor">constructor</a>
AB ab{42};

{
    AB local_ab{};
} // <a href="#rvariant.dtor">destructor</a>

ab<a href="#rvariant.mod">.emplace</a>&lt;int&gt;(123);
ab<a href="#rvariant.mod">.emplace</a>&lt;0&gt;(123);

// <a href="#rvariant.assign">assignment</a>
ab = AB{123};

A&amp; a = temp_ns::<a href="#rvariant.get">get</a>&lt;0&gt;(ab);
A&amp; a = temp_ns::get&lt;A&gt;(ab);
C&amp; c = temp_ns::get&lt;C&gt;(ab);     // throws <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a>

A* a = temp_ns::<a href="#rvariant.get">get_if</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get_if&lt;A&gt;(&amp;ab);
C* c = temp_ns::get_if&lt;C&gt;(&amp;ab); // <code>nullptr</code>

// compatibility with boost; same effect as <code>get_if</code>
A* a = temp_ns::<a href="#rvariant.get">get</a>&lt;0&gt;(&amp;ab);
A* a = temp_ns::get&lt;A&gt;(&amp;ab);
C* c = temp_ns::get&lt;C&gt;(&amp;ab);    // <code>nullptr</code>

<a href="https://eel.is/c++draft/variant.relops#lib:operator==,variant">ab == ab</a>;
<a href="https://eel.is/c++draft/variant.relops#lib:operator&lt;,variant">ab &lt; ab</a>;
<a href="https://eel.is/c++draft/variant.relops#lib:operator&lt;=&gt;,variant">ab &lt;=&gt; ab</a>; // <code>requires (<a href="https://en.cppreference.com/w/cpp/utility/compare/three_way_comparable">std::three_way_comparable</a>&lt;Ts&gt; &amp;&amp; ...)</code>

auto visitor = temp_ns::overloaded {
    [](A const&amp; a) {},
    [](B const&amp; b) {},
};

ab<a href="#rvariant.visit">.visit</a>(visitor);           // member visit
temp_ns::<a href="#rvariant.visit">visit</a>(visitor, ab); // function visit</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-features"><a class="anchor" href="#advanced-features"></a>Advanced Features</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">{
    // <a href="#rvariant.ctor">flexible construction</a>
    AB ab{BA{}};   // unordered construction
    ABC abc{AB{}}; // subset construction

    // <a href="#rvariant.assign">flexible assignment</a>
    ab = BA{};     // unordered assignment
    abc = AB{};    // subset assignment
}

static_assert(temp_ns::<a href="#rvariant.syn">variant_size_v</a>&lt;AB&gt; == 2);
static_assert(std::same_as&lt;temp_ns::<a href="#rvariant.helper">variant_alternative_t</a>&lt;0, AB&gt;, A&gt;);
static_assert(temp_ns::<a href="#rvariant.get">holds_alternative</a>&lt;A&gt;(ab));

static_assert(!ab<a href="#rvariant.status">.valueless_by_exception</a>());
static_assert(ab<a href="#rvariant.status">.index</a>() != <a href="https://eel.is/c++draft/variant.syn">std::variant_npos</a>);

{
    AB tmp;
    ab<a href="#rvariant.swap">.swap</a>(tmp);
}
{
    using std::swap;
    AB tmp;
    <a href="#rvariant.syn">swap</a>(ab, tmp); // ADL
}

std::size_t _ = <a href="#rvariant.hash">std::hash</a>&lt;AB&gt;{ab}();
std::size_t _ = <a href="#rvariant.hash">hash_value</a>(ab); // compatibility with boost

// <a href="#rvariant.io">I/O support</a>
{
    using V = ::temp_ns::rvariant&lt;int, double&gt;;

    // <a href="#rvariant.io.ostream"><code>operator&lt;&lt;</code> support</a>
    std::cout &lt;&lt; V{42} &lt;&lt; '\n';  // prints <code>42</code>

    // <a href="#rvariant.io.format"><code>std::formatter</code> support</a>
    std::println("{}", V{42});   // prints <code>42</code>

    constexpr auto v_fmt = temp_ns::variant_format_for&lt;V&gt;("{:04d}", "{:.1f}");
    std::println("foo{}bar", temp_ns::format_by(v_fmt, V(42)); // prints <code>foo0042bar</code>
    std::println("foo{}bar", temp_ns::format_by(v_fmt, V(3.14)); // prints <code>foo3.1bar</code>
}</code></pre>
</div>
</div>
</div>
</div>
<h1 id="rvariant" class="sect0"><a class="anchor" href="#rvariant"></a>Reference <span class="slug"><a href="#rvariant">[rvariant]</a></span></h1>
<div class="sect1">
<h2 id="rvariant.general"><a class="anchor" href="#rvariant.general"></a>General <span class="slug"><a href="#rvariant.general">[rvariant.general]</a></span></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>In <a href="#rvariant">[rvariant]</a>, <code><em>GET</em></code> denotes a set of exposition-only function templates (<a href="#rvariant.get">[rvariant.get]</a>).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.syn"><a class="anchor" href="#rvariant.syn"></a>Header &lt;temp_ns/rvariant.hpp&gt; synopsis <span class="slug"><a href="#rvariant.syn">[rvariant.syn]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;compare&gt;
#include &lt;memory&gt;      // for <code>std::allocator</code>, etc.
#include &lt;type_traits&gt; // for <code>std::add_pointer</code>, etc.
#include &lt;utility&gt;     // for <code>std::in_place_type</code>, etc.
#include &lt;variant&gt;     // for compatibility with <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a>, etc.

namespace temp_ns {

// <a href="#rvariant.rvariant">[rvariant.rvariant]</a>, class template <code>rvariant</code>
template&lt;class... Ts&gt;
class rvariant;

// <a href="#rvariant.recursive">[rvariant.recursive]</a>, class template <code>recursive_wrapper</code>
template&lt;class T, class Allocator = std::allocator&lt;T&gt;&gt;
class recursive_wrapper;

/* all features commented below defined as per <a href="https://eel.is/c++draft/variant">[variant]</a> */
    // variant_size, variant_size_v
    // operator==
    // operator!=
    // operator&lt;
    // operator&gt;
    // operator&lt;=
    // operator&gt;=
    // operator&lt;=&gt;
    // swap

<a href="https://eel.is/c++draft/variant.syn">/* not defined; use the <code>std::</code> versions instead */</a>
    // variant_npos
    // monostate and monostate-related functionalities
    // <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a>

// <a href="#rvariant.helper">[rvariant.helper]</a>, <code>rvariant</code> helper classes
template&lt;std::size_t I, class T&gt; struct variant_alternative; // not defined
template&lt;std::size_t I, class T&gt; struct variant_alternative&lt;I, T const&gt;;
template&lt;std::size_t I, class T&gt;
  using variant_alternative_t = typename variant_alternative&lt;I, T&gt;::type;

template&lt;std::size_t I, class... Ts&gt;
  struct variant_alternative&lt;I, rvariant&lt;Ts...&gt;&gt;;

// <a href="#rvariant.get">[rvariant.get]</a>, value access
template&lt;class T, class... Ts&gt;
  constexpr bool holds_alternative(rvariant&lt;Ts...&gt; const&amp;) noexcept;

template&lt;std::size_t I, class... Ts&gt;
  constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;
    get(rvariant&lt;Ts...&gt;&amp;);
template&lt;std::size_t I, class... Ts&gt;
  constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;&amp;
    get(rvariant&lt;Ts...&gt;&amp;&amp;);
template&lt;std::size_t I, class... Ts&gt;
  constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&amp;
    get(rvariant&lt;Ts...&gt; const&amp;);
template&lt;std::size_t I, class... Ts&gt;
  constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&amp;&amp;
    get(rvariant&lt;Ts...&gt; const&amp;&amp;);

template&lt;class T, class... Ts&gt; constexpr T&amp;        get(rvariant&lt;Ts...&gt;&amp;);
template&lt;class T, class... Ts&gt; constexpr T&amp;&amp;       get(rvariant&lt;Ts...&gt;&amp;&amp;);
template&lt;class T, class... Ts&gt; constexpr T const&amp;  get(rvariant&lt;Ts...&gt; const&amp;);
template&lt;class T, class... Ts&gt; constexpr T const&amp;&amp; get(rvariant&lt;Ts...&gt; const&amp;&amp;);

template&lt;std::size_t I, class... Ts&gt;
  constexpr std::add_pointer_t&lt;variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&gt;
    get_if(rvariant&lt;Ts...&gt;*) noexcept;
template&lt;std::size_t I, class... Ts&gt;
  constexpr std::add_pointer_t&lt;variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&gt;
    get_if(rvariant&lt;Ts...&gt; const*) noexcept;

template&lt;class T, class... Ts&gt;
  constexpr std::add_pointer_t&lt;T&gt;
    get_if(rvariant&lt;Ts...&gt;*) noexcept;
template&lt;class T, class... Ts&gt;
  constexpr std::add_pointer_t&lt;T const&gt;
    get_if(rvariant&lt;Ts...&gt; const*) noexcept;

// <a href="#rvariant.visit">[rvariant.visit]</a>, visitation
template&lt;class Visitor, class... Variants&gt;
  constexpr <span class="see-below">see below</span> visit(Visitor&amp;&amp;, Variants&amp;&amp;...);
template&lt;class R, class Visitor, class... Variants&gt;
  constexpr R visit(Visitor&amp;&amp;, Variants&amp;&amp;...);

// <a href="#rvariant.hash">[rvariant.hash]</a>, hash support
template&lt;class... Ts&gt;
  /* constexpr */ std::size_t hash_value(rvariant&lt;Ts...&gt; const&amp;);

// <a href="#rvariant.hash">[rvariant.hash]</a>, hash support
template&lt;class T, class Allocator&gt;
  /* constexpr */ std::size_t hash_value(recursive_wrapper&lt;T, Allocator&gt; const&amp;);

// <a href="#rvariant.recursive.helper">[rvariant.recursive.helper]</a>, <code>recursive_wrapper</code> helper classes
template&lt;class T&gt; struct unwrap_recursive;
template&lt;class T, class Allocator&gt; struct unwrap_recursive&lt;recursive_wrapper&lt;T, Allocator&gt;&gt;;
template&lt;class T&gt; using unwrap_recursive_t = typename unwrap_recursive&lt;T&gt;::type;

// <a href="#rvariant.pack">[rvariant.pack]</a>, pack manipulation and deduping
template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
  struct compact_alternative;
template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
  using compact_alternative_t = typename compact_alternative&lt;TT, A, B&gt;::type;

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace std {

// <a href="#rvariant.hash">[rvariant.hash]</a>, hash support
template&lt;class... Ts&gt; struct hash&lt;::temp_ns::rvariant&lt;Ts...&gt;&gt;;

// <a href="#rvariant.hash">[rvariant.hash]</a>, hash support
template&lt;class T, class Allocator&gt; struct hash&lt;::temp_ns::recursive_wrapper&lt;T, Allocator&gt;&gt;;

} // std</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.rvariant"><a class="anchor" href="#rvariant.rvariant"></a>Class template <code>rvariant</code> <span class="slug"><a href="#rvariant.rvariant">[rvariant.rvariant]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class... Ts&gt;
class rvariant
{
public:
  // <a href="#rvariant.ctor">[rvariant.ctor]</a>, constructors
  constexpr rvariant::rvariant() noexcept(<span class="see-below">see below</span>);
  constexpr rvariant::rvariant(rvariant const&amp;);
  constexpr rvariant::rvariant(rvariant&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  template&lt;class T&gt;
    constexpr rvariant(T&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  template&lt;class T, class... Args&gt;
    constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;...);
  template&lt;class T, class U, class... Args&gt;
    constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class... Args&gt;
    constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class U, class... Args&gt;
    constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

  // <a href="#rvariant.ctor">[rvariant.ctor]</a>, flexible constructors
  template&lt;class... Us&gt;
    constexpr rvariant(rvariant&lt;Us...&gt; const&amp;);
  template&lt;class... Us&gt;
    constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  // <a href="#rvariant.dtor">[rvariant.dtor]</a>, destructor
  constexpr ~rvariant();

  // <a href="#rvariant.assign">[rvariant.assign]</a>, assignment
  constexpr rvariant&amp; operator=(rvariant const&amp;);
  constexpr rvariant&amp; operator=(rvariant&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  template&lt;class T&gt; constexpr rvariant&amp; operator=(T&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  // <a href="#rvariant.assign">[rvariant.assign]</a>, flexible assignment
  template&lt;class... Us&gt;
    constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp;);
  template&lt;class... Us&gt;
    constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp;) noexcept(<span class="see-below">see below</span>);

  // <a href="#rvariant.mod">[rvariant.mod]</a>, modifiers
  template&lt;class T, class... Args&gt;
    constexpr T&amp; emplace(Args&amp;&amp;...);
  template&lt;class T, class U, class... Args&gt;
    constexpr T&amp; emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);
  template&lt;std::size_t I, class... Args&gt;
    constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp; emplace(Args&amp;&amp;...);
  template&lt;std::size_t I, class U, class... Args&gt;
    constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;
      emplace(std::initializer_list&lt;U&gt;, Args&amp;&amp;...);

  // <a href="#rvariant.status">[rvariant.status]</a>, value status
  constexpr bool valueless_by_exception() const noexcept;
  constexpr std::size_t index() const noexcept;

  // <a href="#rvariant.subset">[rvariant.subset]</a>, subset
  template&lt;class... Us&gt;
    constexpr rvariant&lt;Us...&gt; subset() const&amp; noexcept(<span class="see-below">see below</span>);
  template&lt;class... Us&gt;
    constexpr rvariant&lt;Us...&gt; subset() &amp;&amp; noexcept(<span class="see-below">see below</span>);

  // <a href="#rvariant.swap">[rvariant.swap]</a>, swap
  constexpr void swap(rvariant&amp;) noexcept(<span class="see-below">see below</span>);

  // <a href="#rvariant.visit">[rvariant.visit]</a>, visitation
  template&lt;class Self, class Visitor&gt;
    constexpr decltype(auto) visit(this Self&amp;&amp;, Visitor&amp;&amp;);
  template&lt;class R, class Self, class Visitor&gt;
    constexpr R visit(this Self&amp;&amp;, Visitor&amp;&amp;);
};

} // temp_ns</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.rvariant.general"><a class="anchor" href="#rvariant.rvariant.general"></a>General <span class="slug"><a href="#rvariant.rvariant.general">[rvariant.rvariant.general]</a></span></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See also: spec of <a href="https://eel.is/c++draft/variant"><code>std::variant</code></a> and <a href="https://www.boost.org/doc/libs/1_88_0/doc/html/variant/reference.html#variant.concepts"><code>boost::variant</code></a>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Class template <code>rvariant</code> follows all requirements of <code>std::variant</code>, unless otherwise noted.</p>
</li>
<li>
<p>All types in <code>Ts</code> must satisfy all requirements on the corresponding parameter in <code>std::variant</code>, unless otherwise noted.</p>
</li>
<li>
<p><span class="underline">Let <code>T</code> and <code>A</code> denote arbitrary types. For the template parameter of <code>rvariant</code>, if a user provides both <code>T</code> and <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T, A&gt;</code> , the program is ill-formed.</span></p>
</li>
<li>
<p><span class="underline">Let <code>T</code> denote an arbitrary type. For the template parameter of <code>rvariant</code>, if a user provides multiple different specializations of <code><a href="#rvariant.recursive">recursive_wrapper</a></code> such that the first template parameter is <code>T</code>, the program is ill-formed.</span></p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Although <code>rvariant</code> is normally capable of holding duplicate alternatives, the above restriction exists for preventing error-prone instantiation of <code>rvariant</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">rvariant&lt;
  int, recursive_wrapper&lt;int&gt;, recursive_wrapper&lt;int, MyAllocator&lt;int&gt;&gt;
&gt; v(42); // error-prone; not allowed</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Let <code>VT<sub><em>i</em></sub></code> denote <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T<sub><em>i</em></sub>, A&gt;</code> (for any type <code>A</code>) if such a specialization occurs anywhere in <code>Ts...</code>; otherwise, let <code>VT<sub><em>i</em></sub></code> denote <code>T<sub><em>i</em></sub></code>. Let <code>U<sub><em>j</em></sub></code> denote the <em>j</em><sup>th</sup> type of the template parameter pack having the name <code>Us</code> on each flexibility-related functions. <span class="underline">The <em>corresponding alternative</em> for <code>rvariant</code> is the first type for which <code>std::is_same_v&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;VT<sub><em>i</em></sub>&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;U<sub><em>j</em></sub>&gt;&gt;</code> is <code>true</code></span>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.ctor"><a class="anchor" href="#rvariant.ctor"></a>Constructors <span class="slug"><a href="#rvariant.ctor">[rvariant.ctor]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr rvariant::rvariant() noexcept(<span class="see-below">see below</span>);<span class="candidate">// 1</span>
constexpr rvariant::rvariant(rvariant const&amp; w);<span class="candidate">// 2</span>
constexpr rvariant::rvariant(rvariant&amp;&amp; w) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 3</span>

// Generic constructor
template&lt;class T&gt;
constexpr rvariant(T&amp;&amp; t) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 4</span>


template&lt;class T, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);<span class="candidate">// 5</span>

template&lt;class T, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_type_t&lt;T&gt;, std::initializer_list&lt;U&gt; il, Args&amp;&amp;...);<span class="candidate">// 6</span>

template&lt;std::size_t I, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, Args&amp;&amp;... args);<span class="candidate">// 7</span>

template&lt;std::size_t I, class U, class... Args&gt;
constexpr explicit rvariant(std::in_place_index_t&lt;I&gt;, std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args);<span class="candidate">// 8</span>


// Flexible copy constructor
template&lt;class... Us&gt;
constexpr rvariant(rvariant&lt;Us...&gt; const&amp; w);<span class="candidate">// 9</span>

// Flexible move constructor
template&lt;class... Us&gt;
constexpr rvariant(rvariant&lt;Us...&gt;&amp;&amp; w) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 10</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-3)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">4)</span> <em>Generic constructor</em>. Equivalent to the <code>std::variant</code> counterpart, <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup> except:</p>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> <code>holds_alternative<span class="underline">&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>j</em></sub>&gt;&gt;</span>(*this)</code> is <code>true</code>.</p>
</div>
</li>
<li>
<p><span class="candidate">5)</span> <strong><em>Mandates:</em></strong> <span class="underline"><code>T</code> is not a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code></span>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT</code> denote <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T, A&gt;</code> (for any type <code>A</code>) if such a specialization occurs anywhere in <code>Ts...</code>; otherwise, let <code>VT</code> denote <code>T</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;There is exactly one occurrence of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;...</code></span> and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_constructible_v&lt;<span class="underline">VT</span>, Args...&gt;</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Direct-non-list-initializes the contained value of type <span class="underline"><code>VT</code></span> with <code>std::forward&lt;Args&gt;(args)...</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> <code>holds_alternative&lt;T&gt;(*this)</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by calling the selected constructor of <span class="underline"><code>VT</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong>  If <span class="underline"><code>VT</code></span>'s selected constructor is a constexpr constructor, this constructor is a constexpr constructor.</p>
</div>
</li>
<li>
<p><span class="candidate">6)</span> <strong><em>Mandates:</em></strong> <span class="underline"><code>T</code> is not a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code></span>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT</code> denote <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T, A&gt;</code> (for any type <code>A</code>) if such a specialization occurs anywhere in <code>Ts...</code>; otherwise, let <code>VT</code> denote <code>T</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;There is exactly one occurrence of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;...</code></span> and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_constructible_v&lt;<span class="underline">VT</span>, std::initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Direct-non-list-initializes the contained value of type <span class="underline"><code>VT</code></span> with <code>il, std::forward&lt;Args&gt;(args)...</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> <code>holds_alternative&lt;T&gt;(*this)</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by calling the selected constructor of <span class="underline"><code>VT</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong>  If <span class="underline"><code>VT</code></span>'s selected constructor is a constexpr constructor, this constructor is a constexpr constructor.</p>
</div>
</li>
<li>
<p><span class="candidate">7-8)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.ctor">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">9)</span> <em>Flexible copy constructor</em>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT<sub><em>i</em></sub></code> and <code>U<sub><em>j</em></sub></code> denote the types defined in <a href="#rvariant.rvariant.general">[rvariant.rvariant.general]</a></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code><a href="#rvariant.flex">rvariant_set::subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::disjunction_v&lt;std::is_same&lt;rvariant&lt;Us...&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;&gt;...&gt;</code> is <code>false</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::is_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub> const&amp;&gt;</code> is <code>true</code> for all <em>j</em>.</span></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>w</code> holds a value, initializes the <code>rvariant</code> to hold <span class="underline"><code>VT<sub><em>i</em></sub></code> (with <em>i</em> being the index of the alternative corresponding to that of <code>w</code>)</span> and direct-initializes the contained value with <code><em>GET</em>&lt;w.index()&gt;(w)</code>. Otherwise, initializes the <code>rvariant</code> to not hold a value.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by direct-initializing any <span class="underline">alternative corresponding to that of <code>w</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The exception specification is equivalent to the logical <code>AND</code> of <span class="underline"><code>std::is_nothrow_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub> const&amp;&gt;</code> for all <em>j</em>.</span></p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">10)</span> <em>Flexible move constructor</em>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT<sub><em>i</em></sub></code> and <code>U<sub><em>j</em></sub></code> denote the types defined in <a href="#rvariant.rvariant.general">[rvariant.rvariant.general]</a></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code><a href="#rvariant.flex">rvariant_set::subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::disjunction_v&lt;std::is_same&lt;rvariant&lt;Us...&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;&gt;...&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_constructible_v&lt;VT<sub><em>i</em></sub>, <span class="underline">U<sub><em>j</em></sub>&amp;&amp;</span>&gt;</code> is <code>true</code> for all <em>j</em>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>w</code> holds a value, initializes the <code>rvariant</code> to hold <code>VT<sub><em>i</em></sub></code> (with <em>i</em> being the index of the alternative corresponding to that of <code>w</code>) and direct-initializes the contained value with <code><em>GET</em>&lt;w.index()&gt;(<span class="underline">std::move(w)</span>)</code>. Otherwise, initializes the <code>rvariant</code> to not hold a value.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by <span class="underline">move-constructing</span> any alternative corresponding to that of <code>w</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The exception specification is equivalent to the logical <code>AND</code> of <code>std::is_nothrow_constructible_v&lt;VT<sub><em>i</em></sub>, <span class="underline">U<sub><em>j</em></sub>&amp;&amp;</span>&gt;</code> for all <em>j</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.dtor"><a class="anchor" href="#rvariant.dtor"></a>Destructor <span class="slug"><a href="#rvariant.dtor">[rvariant.dtor]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr ~rvariant();<span class="candidate">// 1</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.dtor">[spec]</a></sup></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.assign"><a class="anchor" href="#rvariant.assign"></a>Assignment <span class="slug"><a href="#rvariant.assign">[rvariant.assign]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr rvariant&amp; operator=(rvariant const&amp; rhs);<span class="candidate">// 1</span>
constexpr rvariant&amp; operator=(rvariant&amp;&amp; rhs) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 2</span>

// Generic assignment operator
template&lt;class T&gt;
constexpr rvariant&amp; operator=(T&amp;&amp; t) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 3</span>

// Flexible copy assignment operator
template&lt;class... Us&gt;
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt; const&amp; rhs);<span class="candidate">// 4</span>

// Flexible move assignment operator
template&lt;class... Us&gt;
constexpr rvariant&amp; operator=(rvariant&lt;Us...&gt;&amp;&amp; rhs) noexcept(<span class="see-below">see below</span>);<span class="candidate">// 5</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-2)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.assign">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">3)</span> <em>Generic assignment operator</em>. Equivalent to the <code>std::variant</code> counterpart, <sup><a href="https://eel.is/c++draft/variant.assign">[spec]</a></sup> except:</p>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> <code>holds_alternative<span class="underline">&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>j</em></sub>&gt;&gt;</span>(*this)</code> is <code>true</code>, with <code>T<sub><em>j</em></sub></code> selected by the imaginary function overload resolution described above.</p>
</div>
</li>
<li>
<p><span class="candidate">4)</span> <em>Flexible copy assignment operator</em>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT<sub><em>i</em></sub></code> and <code>U<sub><em>j</em></sub></code> denote the types defined in <a href="#rvariant.rvariant.general">[rvariant.rvariant.general]</a></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code><a href="#rvariant.flex">rvariant_set::subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::disjunction_v&lt;std::is_same&lt;rvariant&lt;Us...&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;&gt;...&gt;</code> is <code>false</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::is_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub> const&amp;&gt; &amp;&amp; std::is_assignable_v&lt;VT<sub><em>i</em></sub>&amp;, U<sub><em>j</em></sub> const&amp;&gt;</code> is <code>true</code> for all <em>j</em>.</span></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Let <em>j</em> be <code>rhs.index()</code>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>rhs</code> holds a value but <code>*this</code> does not, initializes <code>rvariant</code> to hold <span class="underline"><code>VT<sub><em>i</em></sub></code> (with <em>i</em> being the index of the alternative corresponding to that of <code>rhs</code>)</span> and direct-initializes the contained value with <span class="underline"><code><em>GET</em>&lt;<em>j</em>&gt;(rhs)</code>.</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <span class="underline"><code>std::is_same_v&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>i</em></sub>&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;U<sub><em>j</em></sub>&gt;&gt;</code> is <code>true</code></span>, assigns <span class="underline"><code><em>GET</em>&lt;<em>j</em>&gt;(rhs)</code></span> to the value contained in <code>*this</code>. <span class="underline">(<em>Note:</em> the left hand side is <code>T<sub><em>i</em></sub></code>, <em>not</em> <code>VT<sub><em>i</em></sub></code>. This ensures that the existing storage is reused even for <code>rvariant</code> with duplicate corresponding alternatives; i.e. <code>index()</code> is unchanged.)</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if either <code>std::is_nothrow_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub> const&amp;&gt;</code> is <code>true</code> or <code>std::is_nothrow_move_constructible_v&lt;VT<sub><em>i</em></sub>&gt;</code> is <code>false</code>, equivalent to <code>emplace<span class="underline">&lt;VT<sub><em>i</em></sub>&gt;</span>(<em>GET</em>&lt;<em>j</em>&gt;(rhs))</code>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, equivalent to <code>emplace&lt;VT<sub><em>i</em></sub>&gt;(<span class="underline">VT<sub><em>i</em></sub></span>(<em>GET</em>&lt;<em>j</em>&gt;(rhs)))</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Postconditions:</em></strong> If <code>rhs.valueless_by_exception()</code> is <code>true</code>, <code>index() == rhs.index()</code>; <span class="underline">otherwise, <code>*this</code> holds the alternative corresponding to that of <code>rhs</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>*this</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> The exception specification is equivalent to the logical <code>AND</code> of <span class="underline"><code>std::is_nothrow_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub> const&amp;&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;VT<sub><em>i</em></sub>&amp;, U<sub><em>j</em></sub> const&amp;&gt;</code> for all <em>j</em>.</span></p>
</div>
</li>
<li>
<p><span class="candidate">5)</span> <em>Flexible move assignment operator</em>.</p>
<div class="paragraph">
<p><span class="underline">Let <code>VT<sub><em>i</em></sub></code> and <code>U<sub><em>j</em></sub></code> denote the types defined in <a href="#rvariant.rvariant.general">[rvariant.rvariant.general]</a></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>false</code>,</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code><a href="#rvariant.flex">rvariant_set::subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::disjunction_v&lt;std::is_same&lt;rvariant&lt;Us...&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;&gt;...&gt;</code> is <code>false</code>, and</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::is_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub>&amp;&amp;&gt; &amp;&amp; std::is_assignable_v&lt;VT<sub><em>i</em></sub>&amp;, U<sub><em>j</em></sub>&amp;&amp;&gt;</code> is <code>true</code> for all <em>j</em>.</span></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Let <em>j</em> be <code>rhs.index()</code>.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;If neither <code>*this</code> nor <code>rhs</code> holds a value, there is no effect.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>*this</code> holds a value but <code>rhs</code> does not, destroys the value contained in <code>*this</code> and sets <code>*this</code> to not hold a value.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <code>rhs</code> holds a value but <code>*this</code> does not, initializes <code>rvariant</code> to hold <span class="underline"><code>VT<sub><em>i</em></sub></code> (with <em>i</em> being the index of the alternative corresponding to that of <code>rhs</code>)</span> and direct-initializes the contained value with <span class="underline"><code><em>GET</em>&lt;<em>j</em>&gt;(std::move(rhs))</code>.</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, if <span class="underline"><code>std::is_same_v&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>i</em></sub>&gt;, <a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;U<sub><em>j</em></sub>&gt;&gt;</code> is <code>true</code></span>, assigns <span class="underline"><code><em>GET</em>&lt;<em>j</em>&gt;(std::move(rhs))</code></span> to the value contained in <code>*this</code>. <span class="underline">(<em>Note:</em> the left hand side is <code>T<sub><em>i</em></sub></code>, <em>not</em> <code>VT<sub><em>i</em></sub></code>. This ensures that the existing storage is reused even for <code>rvariant</code> with duplicate corresponding alternatives; i.e. <code>index()</code> is unchanged.)</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;Otherwise, equivalent to <code>emplace<span class="underline">&lt;VT<sub><em>i</em></sub>&gt;</span>(<em>GET</em>&lt;<em>j</em>&gt;(std::move(rhs)))</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>*this</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> The exception specification is equivalent to the logical <code>AND</code> of <span class="underline"><code>std::is_nothrow_constructible_v&lt;VT<sub><em>i</em></sub>, U<sub><em>j</em></sub>&amp;&amp;&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;VT<sub><em>i</em></sub>&amp;, U<sub><em>j</em></sub>&amp;&amp;&gt;</code> for all <em>j</em>.</span></p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.mod"><a class="anchor" href="#rvariant.mod"></a>Modifiers <span class="slug"><a href="#rvariant.mod">[rvariant.mod]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class T, class... Args&gt;
constexpr T&amp; emplace(Args&amp;&amp;... args);<span class="candidate">// 1</span>

template&lt;class T, class U, class... Args&gt;
constexpr T&amp; emplace(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args);<span class="candidate">// 2</span>

template&lt;std::size_t I, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;
  emplace(Args&amp;&amp;... args);<span class="candidate">// 3</span>

template&lt;std::size_t I, class U, class... Args&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;
  emplace(std::initializer_list&lt;U&gt; il, Args&amp;&amp;... args);<span class="candidate">// 4</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> <span class="underline">Let <code>VT</code> denote <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T, A&gt;</code> (for any type <code>A</code>) if such a specialization occurs anywhere in <code>Ts...</code>; otherwise, let <code>VT</code> denote <code>T</code>.</span></p>
<div class="paragraph">
<p><strong><em>Mandates:</em></strong> <span class="underline"><code>T</code> is not a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong> <code>std::is_constructible_v&lt;<span class="underline">VT</span>, Args...&gt;</code> is <code>true</code>, and <code>T</code> occurs exactly once in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Equivalent to:<br>
&nbsp;&nbsp;<code>return emplace&lt;<em>I</em>&gt;(std::forward&lt;Args&gt;(args)...);</code><br>
where <code><em>I</em></code> is the zero-based index of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
</li>
<li>
<p><span class="candidate">2)</span> <span class="underline">Let <code>VT</code> denote <code><a href="#rvariant.recursive">recursive_wrapper</a>&lt;T, A&gt;</code> (for any type <code>A</code>) if such a specialization occurs anywhere in <code>Ts...</code>; otherwise, let <code>VT</code> denote <code>T</code>.</span></p>
<div class="paragraph">
<p><strong><em>Mandates:</em></strong> <span class="underline"><code>T</code> is not a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Constraints:</em></strong> <code>std::is_constructible_v&lt;<span class="underline">VT</span>, std::initializer_list&lt;U&gt;&amp;, Args...&gt;</code> is <code>true</code>, and <code>T</code> occurs exactly once in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Equivalent to:<br>
&nbsp;&nbsp;<code>return emplace&lt;<em>I</em>&gt;(il, std::forward&lt;Args&gt;(args)...);</code><br>
where <code><em>I</em></code> is the zero-based index of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
</li>
<li>
<p><span class="candidate">3)</span> Equivalent to the <code>std::variant</code> counterpart, <sup><a href="https://eel.is/c++draft/variant.mod">[spec]</a></sup> except:</p>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <span class="underline">Let <code>o</code> denote</span> a reference to the new contained value. <span class="underline">Returns <code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <span class="underline">If <code>T<sub><em>I</em></sub></code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>, this function is permitted to construct an intermediate variable <code>tmp</code> as if by passing <code>std::forward&lt;Args&gt;(args)...</code> to <code>T<sub><em>I</em></sub></code>'s constructor. Then <code>rvariant</code> direct-non-list-initializes the contained value of <code>T<sub><em>I</em></sub></code> with the argument <code>std::move(tmp)</code>. (<em>Note:</em> This allows optimization where <code>rvariant</code> can be assumed to become never valueless on certain cases.)</span></p>
</div>
</li>
<li>
<p><span class="candidate">4)</span> Equivalent to the <code>std::variant</code> counterpart, <sup><a href="https://eel.is/c++draft/variant.mod">[spec]</a></sup> except:</p>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <span class="underline">Let <code>o</code> denote</span> a reference to the new contained value. <span class="underline">Returns <code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code>.</span></p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <span class="underline">If <code>T<sub><em>I</em></sub></code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>, this function is permitted to construct an intermediate variable <code>tmp</code> as if by passing <code>il, std::forward&lt;Args&gt;(args)...</code> to <code>T<sub><em>I</em></sub></code>'s constructor. Then <code>rvariant</code> direct-non-list-initializes the contained value of <code>T<sub><em>I</em></sub></code> with the argument <code>std::move(tmp)</code>. (<em>Note:</em> This allows optimization where <code>rvariant</code> can be assumed to become never valueless on certain cases.)</span></p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.status"><a class="anchor" href="#rvariant.status"></a>Value status <span class="slug"><a href="#rvariant.status">[rvariant.status]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr bool valueless_by_exception() const noexcept;
constexpr std::size_t index() const noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.status">[spec]</a></sup></p>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.subset"><a class="anchor" href="#rvariant.subset"></a>Subset <span class="slug"><a href="#rvariant.subset">[rvariant.subset]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class... Us&gt;
  requires std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;
constexpr rvariant subset() const&amp; noexcept(std::is_nothrow_copy_constructible_v&lt;rvariant&gt;);<span class="candidate">// 1</span>

template&lt;class... Us&gt;
  requires std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;
constexpr rvariant subset() &amp;&amp; noexcept(std::is_nothrow_move_constructible_v&lt;rvariant&gt;);<span class="candidate">// 2</span>

template&lt;class... Us&gt;
  requires (!std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;)
constexpr rvariant&lt;Us...&gt; subset() const&amp; noexcept(<span class="see-below">see below</span>);<span class="candidate">// 3</span>

template&lt;class... Us&gt;
  requires (!std::is_same_v&lt;rvariant&lt;Us...&gt;, rvariant&gt;)
constexpr rvariant&lt;Us...&gt; subset() &amp;&amp; noexcept(<span class="see-below">see below</span>);<span class="candidate">// 4</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Returns:</em></strong> <code>*this</code>.</p>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by copy-constructing any type in <code>Us</code>.</p>
</div>
</li>
<li>
<p><span class="candidate">2)</span> <strong><em>Returns:</em></strong> <code>std::move(*this)</code>.</p>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> Any exception thrown by move-constructing any type in <code>Us</code>.</p>
</div>
</li>
<li>
<p><span class="candidate">3)</span>
<strong><em>Mandates:</em></strong> <code>std::is_copy_constructible_v<span class="underline">&lt;U<sub><em>j</em></sub>&gt;</span></code> is <code>true</code> for all <span class="underline"><em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us</code></span>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>*this</code> holds a value, returns an <code>rvariant<span class="underline">&lt;Us...&gt;</span></code> object that holds the <span class="underline">alternative corresponding to that of</span> <code>*this</code>, with its contained value direct-initialized from <code><em>GET</em>&lt;<em>i</em>&gt;(*this)</code>, where <em>i</em> is <code>this-&gt;index()</code>. Otherwise, returns an <code>rvariant<span class="underline">&lt;Us...&gt;</span></code> object that does not hold a value.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a> if <code>*this</code> holds an alternative that is not contained in <span class="underline"><code>Us</code></span>; otherwise, equivalent to the semantics of the <em>flexible copy constructor</em>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong></p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<span class="underline">This function does not participate in overload resolution unless <code><a href="#rvariant.flex">rvariant_set::subset_of</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> is <code>true</code>.</span></p>
</li>
<li>
<p>&#8201;&#8212;&#8201;The exception specification is equivalent to the logical <code>AND</code> of <span class="underline"><code><a href="#rvariant.flex">rvariant_set::equivalent_to</a>&lt;rvariant&lt;Us...&gt;, rvariant&gt;</code> and <code>std::is_nothrow_constructible_v&lt;rvariant&lt;Us...&gt;, rvariant const&amp;&gt;</code></span>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline">The corresponding index on the returned <code>rvariant&lt;Us...&gt;</code> object shall be determined according to the rules defined in <a href="#rvariant.ctor">the flexible copy constructor</a>.</span></p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p><span class="candidate">4)</span> Equivalent to the overload #3, except:</p>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;Citation of <em>flexible copy constructor</em> is replaced with <em>flexible move constructor</em>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Mandates:</em></strong> <code>std::is_move_constructible_v<span class="underline">&lt;U<sub><em>j</em></sub>&gt;</span></code> is <code>true</code> for all <span class="underline"><em>j</em>, where <code>U<sub><em>j</em></sub></code> be the <em>j</em><sup>th</sup> type in <code>Us</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> <code><em>GET</em>&lt;<em>i</em>&gt;(*this)</code> is replaced with <code><em>GET</em>&lt;<em>i</em>&gt;(std::move(*this))</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <code>std::is_nothrow_constructible_v&lt;rvariant&lt;Us...&gt;, rvariant const&amp;&gt;</code> is replaced with <code>std::is_nothrow_constructible_v&lt;rvariant&lt;Us...&gt;, rvariant&amp;&amp;&gt;</code>.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.swap"><a class="anchor" href="#rvariant.swap"></a>Swap <span class="slug"><a href="#rvariant.swap">[rvariant.swap]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr void swap(rvariant&amp;) noexcept(<span class="see-below">see below</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.swap">[spec]</a></sup></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.helper"><a class="anchor" href="#rvariant.helper"></a><code>rvariant</code> helper classes <span class="slug"><a href="#rvariant.helper">[rvariant.helper]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;std::size_t I, class T&gt;
struct variant_alternative; // not defined

template&lt;std::size_t I, class T&gt;
struct variant_alternative&lt;I, T const&gt;;<span class="candidate">// 1</span>

template&lt;std::size_t I, class... Ts&gt;
struct variant_alternative&lt;I, rvariant&lt;Ts...&gt;&gt;;<span class="candidate">// 2</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant#helper-3">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">2)</span> The member typedef <code>type</code> denotes <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>I</em></sub>&gt;</code></span>.</p>
<div class="paragraph">
<p><strong><em>Mandates:</em></strong> <code>I &lt; sizeof...(Ts)</code>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.flex"><a class="anchor" href="#rvariant.flex"></a>Flexibility traits <span class="slug"><a href="#rvariant.flex">[rvariant.flex]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns::rvariant_set {

template&lt;class W, class V&gt;
struct is_subset_of : std::false_type {};<span class="candidate">// 1</span>

template&lt;class... Us, class... Ts&gt;
struct is_subset_of&lt;rvariant&lt;Us...&gt;, rvariant&lt;Ts...&gt;&gt;;<span class="candidate">// 2</span>

template&lt;class W, class V&gt;
constexpr bool is_subset_of_v = is_subset_of&lt;W, V&gt;::value;

template&lt;class W, class V&gt;
concept subset_of = is_subset_of_v&lt;W, V&gt;;

template&lt;class W, class V&gt;
concept equivalent_to = subset_of&lt;W, V&gt; &amp;&amp; subset_of&lt;V, W&gt;;

} // temp_ns::rvariant_set</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Mandates:</em></strong> Both <code>W</code> and <code>V</code> are specialization of <code><a href="#rvariant.rvariant">rvariant</a></code>.</p>
</li>
<li>
<p><span class="candidate">2)</span> <strong><em>Constraints:</em></strong> For every type <code>U</code> in <code>Us</code>, there exists at least one type <code>T</code> in <code>Ts</code> such that:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>T</code> is the same type as <code>U</code> or,</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T&gt;</code> is the same type as <code>U</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.get"><a class="anchor" href="#rvariant.get"></a>Value access <span class="slug"><a href="#rvariant.get">[rvariant.get]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class T, class... Ts&gt;
constexpr bool holds_alternative(rvariant&lt;Ts...&gt; const&amp; v) noexcept;

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> <strong><em>Mandates:</em></strong> The type <code>T</code> occurs exactly once in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>true</code> if <code>v.index()</code> is equal to the zero-based index of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <span class="underline">This function is defined as deleted if <code>T</code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>.</span></p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;std::size_t I, class... Ts&gt;
constexpr <span class="see-below">see below</span>&amp; <em>GET</em>(rvariant&lt;Ts...&gt;&amp; v);               // <span class="exposition-only">exposition only</span>

template&lt;std::size_t I, class... Ts&gt;
constexpr <span class="see-below">see below</span>&amp;&amp; <em>GET</em>(rvariant&lt;Ts...&gt;&amp;&amp; v);             // <span class="exposition-only">exposition only</span>

template&lt;std::size_t I, class... Ts&gt;
constexpr <span class="see-below">see below</span> const&amp; <em>GET</em>(rvariant&lt;Ts...&gt; const&amp; v);   // <span class="exposition-only">exposition only</span>

template&lt;std::size_t I, class... Ts&gt;
constexpr <span class="see-below">see below</span> const&amp;&amp; <em>GET</em>(rvariant&lt;Ts...&gt; const&amp;&amp; v); // <span class="exposition-only">exposition only</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> <strong><em>Mandates:</em></strong> <code>I &lt; sizeof...(Ts)</code>.</p>
<div class="paragraph">
<p><strong><em>Preconditions:</em></strong> <code>v.index()</code> is <code>I</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <span class="underline"><code>o</code>, where <code>o</code> denotes a reference to the object stored in <code>v</code>, if the type of the expression&#8217;s receiver is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>; otherwise, returns <code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code></span>.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;std::size_t I, class... Ts&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;
  get(rvariant&lt;Ts...&gt;&amp; v);

template&lt;std::size_t I, class... Ts&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&amp;&amp;
  get(rvariant&lt;Ts...&gt;&amp;&amp; v);

template&lt;std::size_t I, class... Ts&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&amp;
  get(rvariant&lt;Ts...&gt; const&amp; v);

template&lt;std::size_t I, class... Ts&gt;
constexpr variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&amp;&amp;
  get(rvariant&lt;Ts...&gt; const&amp;&amp; v);

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> <strong><em>Mandates:</em></strong> <code>I &lt; sizeof...(Ts)</code>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> If <code>v.index()</code> is <code>I</code>, returns <span class="underline"><code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code>, where <code>o</code> denotes a reference to the object stored in the <code>rvariant</code></span>. Otherwise, throws an exception of type <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a>.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class T, class... Ts&gt; constexpr T&amp;        get(rvariant&lt;Ts...&gt;&amp; v);
template&lt;class T, class... Ts&gt; constexpr T&amp;&amp;       get(rvariant&lt;Ts...&gt;&amp;&amp; v);
template&lt;class T, class... Ts&gt; constexpr T const&amp;  get(rvariant&lt;Ts...&gt; const&amp; v);
template&lt;class T, class... Ts&gt; constexpr T const&amp;&amp; get(rvariant&lt;Ts...&gt; const&amp;&amp; v);

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> <strong><em>Mandates:</em></strong> The type <code>T</code> occurs exactly once in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> <span class="underline">Let <code>VT</code> denote the type of the alternative held by <code>v</code>. If <code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;VT&gt;</code> is the same type as <code>T</code></span>, returns <span class="underline"><code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code>, where <code>o</code> denotes a reference to the object stored in the <code>rvariant</code></span>. Otherwise, throws an exception of type <a href="https://eel.is/c++draft/variant.bad.access"><code>std::bad_variant_access</code></a>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <span class="underline">This function is defined as deleted if <code>T</code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>.</span></p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;std::size_t I, class... Ts&gt;
constexpr std::add_pointer_t&lt;variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt;&gt;
  get_if(rvariant&lt;Ts...&gt;*) noexcept;<span class="candidate">// 1</span>

template&lt;std::size_t I, class... Ts&gt;
constexpr std::add_pointer_t&lt;variant_alternative_t&lt;I, rvariant&lt;Ts...&gt;&gt; const&gt;
  get_if(rvariant&lt;Ts...&gt; const* v) noexcept;<span class="candidate">// 2</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-2)</span> <strong><em>Mandates:</em></strong> <code>I &lt; sizeof...(Ts)</code>.</p>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> A pointer to the value <span class="underline">denoted by <code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(o)</code>, where <code>o</code> denotes a reference to the object stored in the <code>rvariant</code></span>, if <code>v != nullptr</code> and <code>v-&gt;index() == I</code>. Otherwise, returns <code>nullptr</code>.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class T, class... Ts&gt;
constexpr std::add_pointer_t&lt;T&gt;
  get_if(rvariant&lt;Ts...&gt;* v) noexcept;<span class="candidate">// 1</span>

template&lt;class T, class... Ts&gt;
constexpr std::add_pointer_t&lt;T const&gt;
  get_if(rvariant&lt;Ts...&gt; const* v) noexcept;<span class="candidate">// 2</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-2)</span> <strong><em>Mandates:</em></strong> The type <code>T</code> occurs exactly once in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Equivalent to: <code>return get_if&lt;<em>i</em>&gt;(v);</code> with <em>i</em> being the zero-based index of <code>T</code> in <span class="underline"><code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts&gt;</code></span>.</p>
</div>
<div class="paragraph">
<p><strong><em>Remarks:</em></strong> <span class="underline">This function is defined as deleted if <code>T</code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>.</span></p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.visit"><a class="anchor" href="#rvariant.visit"></a>Visitation <span class="slug"><a href="#rvariant.visit">[rvariant.visit]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class Visitor, class... Variants&gt;
constexpr <span class="see-below">see below</span> visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);<span class="candidate">// 1</span>

template&lt;class R, class Visitor, class... Variants&gt;
constexpr R visit(Visitor&amp;&amp; vis, Variants&amp;&amp;... vars);<span class="candidate">// 2</span>

} // temp_ns

// below are member functions of the class template <a href="#rvariant.rvariant"><code>rvariant</code></a>:

template&lt;class Self, class Visitor&gt;
constexpr decltype(auto) visit(this Self&amp;&amp; self, Visitor&amp;&amp; vis);<span class="candidate">// 3</span>

template&lt;class R, class Self, class Visitor&gt;
constexpr R visit(this Self&amp;&amp; self, Visitor&amp;&amp; vis);<span class="candidate">// 4</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1-2)</span> Equivalent to the <code>std::variant</code> counterpart <sup><a href="https://eel.is/c++draft/variant.visit">[spec]</a></sup>, except that:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code><em>GET</em>&lt;<em>m</em>&gt;(std::forward&lt;V&gt;(vars))</code> is replaced with <code><em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(<em>GET</em>&lt;<em>m</em>&gt;(std::forward&lt;V&gt;(vars)))</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">3-4)</span> Equivalent to the <code>std::variant</code> counterpart <sup><a href="https://eel.is/c++draft/variant.visit">[spec]</a></sup>, except that it forwards to <code>temp_ns::visit</code> instead of <code>std::visit</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.hash"><a class="anchor" href="#rvariant.hash"></a>Hash support <span class="slug"><a href="#rvariant.hash">[rvariant.hash]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace std {

template&lt;class... Ts&gt;
struct hash&lt;::temp_ns::rvariant&lt;Ts...&gt;&gt;;<span class="candidate">// 1</span>

template&lt;class T, class Allocator&gt;
struct hash&lt;::temp_ns::recursive_wrapper&lt;T, Allocator&gt;&gt;;<span class="candidate">// 2</span>

} // std</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class... Ts&gt;
/* constexpr */ std::size_t hash_value(rvariant&lt;Ts...&gt; const&amp; v);<span class="candidate">// 3</span>

template&lt;class T, class Allocator&gt;
/* constexpr */ std::size_t hash_value(recursive_wrapper&lt;T, Allocator&gt; const&amp; rw);<span class="candidate">// 4</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1)</span>
Equivalent to the <code>std::variant</code> counterpart. <sup><a href="https://eel.is/c++draft/variant.hash">[spec]</a></sup></p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="candidate">2)</span>
Equivalent to the <code>std::indirect</code> counterpart. <sup><a href="https://eel.is/c++draft/indirect.hash">[spec]</a></sup></p>
</li>
<li>
<p><span class="candidate">3)</span> <strong><em>Effects:</em></strong> Equivalent to <code>std::hash&lt;rvariant&lt;Ts...&gt;&gt;{}(v)</code>.</p>
</li>
<li>
<p><span class="candidate">4)</span> <strong><em>Effects:</em></strong> Equivalent to <code>std::hash&lt;recursive_wrapper&lt;T, Allocator&gt;&gt;{}(rw)</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.io"><a class="anchor" href="#rvariant.io"></a>I/O <span class="slug"><a href="#rvariant.io">[rvariant.io]</a></span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>I/O components are <em>not</em> included by the global convenience header (<code>&lt;temp_ns/rvariant.hpp&gt;</code>).</p>
</div>
<div class="sect2">
<h3 id="rvariant.io.ostream"><a class="anchor" href="#rvariant.io.ostream"></a><code>operator&lt;&lt;</code> support</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// &lt;temp_ns/rvariant/rvariant_io.hpp&gt;

#include &lt;ostream&gt;

namespace temp_ns {

template&lt;class T&gt;
constexpr bool <em>ADL-ostreamable</em> = <span class="see-below">see below</span>; // <span class="exposition-only">exposition only</span><span class="candidate">// 1</span>

template&lt;class... Ts&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, rvariant&lt;Ts...&gt; const&amp; v);<span class="candidate">// 2</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> Evaluates to <code>true</code> if all of the following conditions are met; otherwise, evaluates to <code>false</code>.</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;Let <code>os</code> denote an lvalue reference to an object of type <code>std::ostream</code>, and let <code>val</code> denote an lvalue reference to an object of type <code>T</code>. These references are valid in unevaluated context, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;the expression <code>os &lt;&lt; val</code> is well-formed and has the type <code>std::ostream&amp;</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;the corresponding overload is found solely via ADL.</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="candidate">2)</span> <strong><em>Constraints:</em></strong> <code><em>ADL-ostreamable</em>&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;T<sub><em>i</em></sub>&gt;&gt;</code> is <code>true</code> for all <em>i</em>.</p>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Behaves as a formatted output function (<a href="https://eel.is/c++draft/ostream.formatted.reqmts">[ostream.formatted.reqmts]</a>) of <code>os</code>, except that:</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;the output is done as if by calling <code>os &lt;&lt; <em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(<em>GET</em>&lt;<em>i</em>&gt;(v))</code> (with <em>i</em> being <code>v.index()</code>), and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;any exception of type <code>std::bad_variant_access</code>, whether thrown directly (i.e. due to <code>v</code> being valueless) or indirectly (i.e. by a nested call to an alternative&#8217;s output function), is propagated without regard to the value of <code>os.exceptions()</code> and without turning on <code>std::ios_base::badbit</code> in the error state of <code>os</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code>os</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Throws:</em></strong> <code>std::bad_variant_access</code> if <code>v.valueless_by_exception()</code> is <code>true</code>. Otherwise, throws any exception thrown as per the formatted output function&#8217;s specification.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.io.format"><a class="anchor" href="#rvariant.io.format"></a><code>std::formatter</code> support</h3>
<div class="ulist none">
<ul class="none">
<li>
<p>Let <code>v</code> denote an object of <code>rvariant</code>, and let <code>proxy</code> denote an object of <code><em>variant_format_proxy</em></code>.</p>
</li>
<li>
<p>The specialization <code>std::formatter&lt;::temp_ns::rvariant&lt;Ts...&gt;, charT&gt;</code> (for arbitrary <code>charT</code>) is enabled if and only if <code>std::formattable&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts<sub><em>i</em></sub>&gt;, charT&gt;</code> is <code>true</code> for all <em>i</em>, with the following characteristics:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The format specifier must be empty, otherwise <code>std::format_error</code> is thrown, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;if <code>v.valueless_by_exception()</code> is <code>true</code>, <code>std::bad_variant_access</code> is thrown, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;the output is done as if by calling <code>std::format_to(fmt_ctx.out(), <em>paren</em>, <em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(<em>GET</em>&lt;v.index()&gt;(v)))</code>, with <code><em>paren</em></code> being a string literal <code>"{}"</code> interpreted on the target character type.</p>
</li>
<li>
<p><em>Example:</em></p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::println("{}", temp_ns::rvariant&lt;int, double&gt;(42)); // prints <code>42</code></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>The specialization <code>std::formatter&lt;<em>variant_format_proxy</em>&lt;VFormat, Variant&gt;, charT&gt;</code> is enabled if and only if:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>std::remove_cvref_t&lt;VFormat&gt;</code> is a specialization of <code><em>variant_format_string</em></code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::remove_cvref_t&lt;Variant&gt;</code> is a specialization of <code>rvariant</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::formattable&lt;<a href="#rvariant.recursive.helper">unwrap_recursive_t</a>&lt;Ts<sub><em>i</em></sub>&gt;, charT&gt;</code> is <code>true</code> for all <em>i</em>, with <code>Ts</code> being the template parameter pack of cv-unqualified non-reference type for <code>Variant</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>It has the following characteristics:</p>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The format specifier must be empty, otherwise <code>std::format_error</code> is thrown, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;if <code>v.valueless_by_exception()</code> is <code>true</code>, <code>std::bad_variant_access</code> is thrown, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;the output is done as if by calling <code>std::format_to(fmt_ctx.out(), proxy.v_fmt(std::in_place_type&lt;Ts...[proxy.v.index()]&gt;), <em><a href="#rvariant.recursive.helper">UNWRAP_RECURSIVE</a></em>(<em>GET</em>&lt;proxy.v.index()&gt;(proxy.v)))</code>, with <code>Ts</code> being the template parameter pack of the cv-unqualified non-reference type of <code>proxy.v</code>.</p>
</li>
<li>
<p><em>Example:</em></p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using V = temp_ns::rvariant&lt;int, double&gt;;
constexpr auto v_fmt = temp_ns::variant_format_for&lt;V&gt;("{:04d}", "{:.1f}");
std::println("foo{}bar", temp_ns::format_by(v_fmt, V(42)); // prints <code>foo0042bar</code>
std::println("foo{}bar", temp_ns::format_by(v_fmt, V(3.14)); // prints <code>foo3.1bar</code></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class... CharLike&gt;
using <em>select-char-t</em> = <span class="see-below">see below</span>; // <span class="exposition-only">exposition only</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> Denotes <code>charT</code>, with <code>charT</code> being the character type for which <code>std::is_convertible_v&lt;CharLike<sub><em>i</em></sub>, std::basic_string_view&lt;charT&gt;&gt;</code> is <code>true</code> for all <em>i</em>. If there exists no such substitution, the program is ill-formed.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// &lt;temp_ns/rvariant/rvariant_io.hpp&gt;

#include &lt;format&gt;

template&lt;class charT, class... Ts&gt;
struct <em>variant_format_string</em> // <span class="exposition-only">exposition only</span>
{
  std::basic_format_string&lt;charT, Ts...[i] const&amp;&gt; fmts...;
  auto const&amp; operator()(std::in_place_type&lt;Ts...[i]&gt;) const noexcept { return fmts...[i]; }
};

namespace temp_ns {

template&lt;class... Ts, class... Fmts&gt;
constexpr <em>variant_format_string</em>&lt;<span class="see-below">see below</span>&gt; variant_format(Fmts&amp;&amp;... fmts) noexcept;<span class="candidate">// 1</span>

template&lt;class Variant, class... Fmts&gt;
constexpr <em>variant_format_string</em>&lt;<span class="see-below">see below</span>&gt; variant_format_for(Fmts&amp;&amp;... fmts) noexcept;<span class="candidate">// 2</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Mandates:</em></strong> <code>std::is_convertible_v&lt;Fmts<sub><em>i</em></sub>, std::basic_format_string&lt;<em>select-char-t</em>&lt;Fmts...&gt;, Ts<sub><em>i</em></sub> const&amp;&gt;&gt;</code> is <code>true</code> for all <em>i</em>, and <code>sizeof...(Ts) &gt; 0</code> is <code>true</code>.</p>
<div class="paragraph">
<p>Let <code>charT</code> denote <code><em>select-char-t</em>&lt;Fmts...&gt;</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code><em>variant_format_string</em>&lt;charT, Ts...&gt;{std::forward&lt;Fmts&gt;(fmts)...}</code>.</p>
</div>
</li>
<li>
<p><span class="candidate">2)</span> <strong><em>Mandates:</em></strong> <code>std::is_convertible_v&lt;Fmts<sub><em>i</em></sub>, std::basic_format_string&lt;<em>select-char-t</em>&lt;Fmts...&gt;, Ts<sub><em>i</em></sub> const&amp;&gt;&gt;</code> is <code>true</code> for all <em>i</em>, with <code>Ts</code> being the template parameter pack of cv-unqualified non-reference type for <code>Variant</code>. Such substitution is valid only if <code>std::remove_cvref_t&lt;Variant&gt;</code> is a specialization of <code>rvariant</code>.</p>
<div class="paragraph">
<p>Let <code>charT</code> denote <code><em>select-char-t</em>&lt;Fmts...&gt;</code>.</p>
</div>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code><em>variant_format_string</em>&lt;charT, Ts...&gt;{std::forward&lt;Fmts&gt;(fmts)...}</code>.</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// &lt;temp_ns/rvariant/rvariant_io.hpp&gt;

#include &lt;format&gt;

template&lt;class VFormat, class Variant&gt;
struct <em>variant_format_proxy</em> // <span class="exposition-only">exposition only</span>
{
    VFormat v_fmt;
    Variant v;
};

namespace temp_ns {

template&lt;class VFormat, class Variant&gt;
constexpr <em>variant_format_proxy</em>&lt;VFormat, Variant&gt;
format_by(VFormat&amp;&amp; v_fmt, Variant&amp;&amp; v) noexcept;<span class="candidate">// 1</span>

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> <strong><em>Constraints:</em></strong> <code>std::remove_cvref_t&lt;VFormat&gt;</code> is a specialization of <code><em>variant_format_string</em></code>, and <code>std::remove_cvref_t&lt;Variant&gt;</code> is a specialization of <code>rvariant</code>.</p>
<div class="paragraph">
<p><strong><em>Returns:</em></strong> <code><em>variant_format_proxy</em>&lt;VFormat, Variant&gt;{std::forward&lt;VFormat&gt;(v_fmt), std::forward&lt;Variant&gt;(v)}</code>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.recursive"><a class="anchor" href="#rvariant.recursive"></a>Class template <code>recursive_wrapper</code> <span class="slug"><a href="#rvariant.recursive">[rvariant.recursive]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">#include &lt;compare&gt;
#include &lt;memory&gt;

namespace temp_ns {

template&lt;class T, class Allocator = std::allocator&lt;T&gt;&gt;
class recursive_wrapper
{
  // provides the same functionality as <a href="https://eel.is/c++draft/indirect"><code>std::indirect</code></a>, unless otherwise noted

  // <a href="#rvariant.recursive.ctor">[rvariant.recursive.ctor]</a>, constructors
  constexpr <span class="underline">/* not explicit */</span> recursive_wrapper();

  template&lt;class U = T&gt;
  constexpr <span class="underline">/* not explicit */</span> recursive_wrapper(U&amp;&amp; x);
};

// equivalent to the <a href="https://eel.is/c++draft/indirect"><code>std::indirect</code></a> counterpart
template&lt;class Value&gt;
  recursive_wrapper(Value) -&gt; recursive_wrapper&lt;Value&gt;;

// equivalent to the <a href="https://eel.is/c++draft/indirect"><code>std::indirect</code></a> counterpart
template&lt;class Allocator, class Value&gt;
  recursive_wrapper(std::allocator_arg_t, Allocator, Value)
    -&gt; recursive_wrapper&lt;
      Value,
      typename std::allocator_traits&lt;Allocator&gt;::template rebind_alloc&lt;Value&gt;
    &gt;;

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">// &lt;temp_ns/rvariant/recursive_wrapper_pmr.hpp&gt;

#include &lt;memory_resource&gt;

namespace temp_ns::pmr {

template&lt;class T&gt;
using recursive_wrapper = ::temp_ns::recursive_wrapper&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;

} // temp_ns::pmr</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.recursive.general"><a class="anchor" href="#rvariant.recursive.general"></a>General <span class="slug"><a href="#rvariant.recursive.general">[rvariant.recursive.general]</a></span></h3>
<div class="paragraph">
<p>Unless otherwise noted, the class template <code>temp_ns::recursive_wrapper</code> and relevant components in the namespace scope provide same functionality and have equivalent requirements as <code>std::indirect</code>, except that:</p>
</div>
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;The class name is <code>recursive_wrapper</code>.</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::indirect</code> and <code>temp_ns::recursive_wrapper</code> are distinguishable in type level.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>temp_ns::recursive_wrapper</code> is <strong>not</strong> a type alias of <code>std::indirect</code> and does <strong>not</strong> publicly derive from it.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although <code>std::indirect</code> is a C&#43;&#43;26 feature, <code>temp_ns::recursive_wrapper</code> can be used in C&#43;&#43;23.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.recursive.ctor"><a class="anchor" href="#rvariant.recursive.ctor"></a>Constructors</h3>
<div class="paragraph">
<p>Effectively overrides only the ones listed below; rest are the same as <code>std::indirect</code> counterparts. <sup><a href="https://eel.is/c++draft/indirect.ctor">[spec]</a></sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">constexpr <span class="underline">/* not explicit */</span> recursive_wrapper();<span class="candidate">// 1</span>

template&lt;class U = T&gt;
constexpr <span class="underline">/* not explicit */</span> recursive_wrapper(U&amp;&amp; u);<span class="candidate">// 2</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate">1)</span> Equivalent to the <code>std::indirect</code> counterpart,<sup><a href="https://eel.is/c++draft/indirect.ctor#lib:indirect,constructor">[spec]</a></sup> except that <span class="underline">it is <em>not</em> <code>explicit</code></span>.</p>
</li>
<li>
<p><span class="candidate">2)</span> <strong><em>Constraints:</em></strong></p>
<div class="openblock">
<div class="content">
<div class="ulist none">
<ul class="none">
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_same_v&lt;std::remove_cvref_t&lt;U&gt;, recursive_wrapper&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_same_v&lt;std::remove_cvref_t&lt;U&gt;, std::in_place_t&gt;</code> is <code>false</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<code>std::is_default_constructible_v&lt;Allocator&gt;</code> is <code>true</code>, and</p>
</li>
<li>
<p>&#8201;&#8212;&#8201;<span class="underline"><code>std::is_convertible_v&lt;U, T&gt;</code> is <code>true</code></span>.</p>
<div class="paragraph">
<p><em>Note 1:</em> <span class="underline">This prevents recursive instantiation of <code>std::is_constructible</code></span>, even for recursive types, while preserving SFINAE-friendliness. This specification is technically viable only because the class template <code>rvariant</code> never uses <code>std::is_convertible</code> in any of its constructor overloads. As a result, the atomic constraints of <code>rvariant</code> and <code>recursive_wrapper</code> remain mutually exclusive. However, if a user-defined class depends on <em>both</em> <code>std::is_constructible</code> and <code>std::is_convertible</code> (for the same <code>rvariant</code> specialization), it may trigger recursive instantiation.</p>
</div>
<div class="paragraph">
<p><em>Note 2:</em> It is currently unknown whether the recursive instantiation scenario described in <em>Note 1</em> can be technically avoided. This note is provided for informational purposes only and does not specify the semantics of <code>recursive_wrapper</code>.</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p><strong><em>Effects:</em></strong> Equivalent to the <code>std::indirect</code> counterpart. <sup><a href="https://eel.is/c++draft/indirect.ctor#lib:indirect,constructor______">[spec]</a></sup></p>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.recursive.helper"><a class="anchor" href="#rvariant.recursive.helper"></a><code>recursive_wrapper</code> helper classes <span class="slug"><a href="#rvariant.recursive.helper">[rvariant.recursive.helper]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;class T&gt;
struct unwrap_recursive
{
  using type = T;
};

template&lt;class T, class Allocator&gt;
struct unwrap_recursive&lt;recursive_wrapper&lt;T, Allocator&gt;&gt;
{
  using type = T;
};

} // temp_ns</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class T&gt;
constexpr <span class="see-below">see below</span> <em>UNWRAP_RECURSIVE</em>(T&amp;&amp; o) noexcept; // <span class="exposition-only">exposition only</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> <strong><em>Effects:</em></strong> Denotes <code>*o</code>, if cv-unqualified non-reference type for <code>T</code> is a specialization of <code><a href="#rvariant.recursive">recursive_wrapper</a></code>. Otherwise, denotes <code>o</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.pack"><a class="anchor" href="#rvariant.pack"></a>Pack manipulation and deduping <span class="slug"><a href="#rvariant.pack">[rvariant.pack]</a></span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">namespace temp_ns {

template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
struct compact_alternative;

} // temp_ns</code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> Effectively concatenates contained types in <code>A</code> and <code>B</code>, then dedupes them. If the resulting type list consists of only a single type, the surrounding template is unwrapped.</p>
<div class="paragraph">
<p><strong><em>Definition:</em></strong>  Let <code>Ts</code> denote an imaginary pack of types where <code>TT&lt;Ts...&gt;</code> is the same type as <code><a href="#rvariant.xo.pack"><em>pack-union-t</em></a>&lt;TT, A, B&gt;</code>. The member typedef <code>type</code> denotes <code>Ts...[0]</code> if <code>sizeof...(Ts) == 1</code>; otherwise, the member typedef <code>type</code> denotes <code>TT&lt;Ts...&gt;</code>.</p>
</div>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="title">Notes on single-type variant</div>
A variant with a single alternative may introduce unnecessary overhead when used in many places where only the underlying type is actually needed. In such cases, the variant can be <em>unwrapped</em> using <code>compact_alternative</code>. This is useful for resolving issues such as <a href="https://github.com/boostorg/spirit/issues/610">boostorg/spirit#610</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>compact_alternative</code> does not unwrap <code><a href="#rvariant.recursive">recursive_wrapper</a></code>. This is intentional, because doing so could lead to instantiating incomplete type on undesired timings. You may apply <code><a href="#rvariant.recursive.helper">unwrap_recursive_t</a></code> manually.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rvariant.xo"><a class="anchor" href="#rvariant.xo"></a>Exposition-only utilities <span class="slug"><a href="#rvariant.xo">[rvariant.xo]</a></span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section demonstrates internal features used in the implementation.</p>
</div>
<div class="sect2">
<h3 id="rvariant.xo.pack"><a class="anchor" href="#rvariant.xo.pack"></a>Pack utilities <span class="slug"><a href="#rvariant.xo.pack">[rvariant.xo.pack]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;template&lt;class...&gt; class TT, class A, class B&gt;
using <em>pack-union-t</em> = <span class="see-below">see below</span>; // <span class="exposition-only">exposition only</span></code></pre>
</div>
</div>
<div class="ulist candidates">
<ul>
<li>
<p><span class="candidate"></span> Let <code>As</code> denote the pack of template parameters of <code>A</code> if <code>A</code> is a specialization of <code>TT</code>, otherwise let <code>As</code> denote a pack of single type <code>A</code>. Let <code>Bs</code> denote likewise. <code><em>pack-union-t</em></code> denotes <code>TT&lt;Ts...&gt;</code>, where <code>Ts...</code> is the set union of <code>As...</code> and <code>Bs...</code> expanded from left to right. For duplicate types, the first occurrence shall remain in <code>Ts...</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="rvariant.xo.core"><a class="anchor" href="#rvariant.xo.core"></a>Core type traits <span class="slug"><a href="#rvariant.xo.core">[rvariant.xo.core]</a></span></h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">template&lt;class T, template&lt;class...&gt; class TT&gt;
struct <em>is-ttp-specialization-of</em>;  // <span class="exposition-only">exposition only</span><span class="candidate">// 1</span>

template&lt;class T, template&lt;auto...&gt; class TT&gt;
struct <em>is-nttp-specialization-of</em>; // <span class="exposition-only">exposition only</span><span class="candidate">// 2</span>

template&lt;class T, <em>any-ttp</em>&gt;
struct <em>is-specialization-of</em>;      // <span class="exposition-only">exposition only</span><span class="candidate">// 3</span></code></pre>
</div>
</div>
<div class="openblock candidates">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><span class="candidate">1-2)</span> Inherits <code>std::true_type</code> if and only if <code>T</code> is a specialization of <code>TT</code>; otherwise, inherits <code>std::false_type</code>.</p>
</li>
<li>
<p><span class="candidate">3)</span> If <code><em>any-ttp</em></code> is a template template parameter that consists of NTTP, equivalent to <code><em>is-nttp-specialization-of</em></code>; otherwise, equivalent to <code><em>is-ttp-specialization-of</em></code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code><em>is-specialization-of</em></code> requires C&#43;&#43;26 reflection for a straightforward resolution. For older versions, it can be worked around by a compound <code>requires</code> expression.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<h1 id="additional-information" class="sect0"><a class="anchor" href="#additional-information"></a>Additional Information</h1>
<div class="sect1">
<h2 id="benchmark"><a class="anchor" href="#benchmark"></a>Benchmark</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The benchmark application <a href="https://github.com/yaito3014/rvariant/blob/f4d08f16cf8001abe384d7857247a7c8eb539098/test/benchmark.cpp" target="_blank" rel="noopener">(source code)</a> measures the performance of <code>rvariant</code> construction and access using randomly generated inputs.</p>
</div>
<div class="paragraph">
<p>It uses <code>std::mt19937</code> for random number generation and constructs <code>rvariant</code> instances directly within a <code>std::vector</code>. For the <code>std::string</code> benchmarks, we simply pass the stringized random numbers.</p>
</div>
<div class="paragraph">
<p>The alternative index is distributed randomly during the construction, making sure that the access to internal <code>union</code> is not overly optimized by the compiler.</p>
</div>
<h4 id="benchmark-environment" class="discrete">Benchmark Environment</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Date</strong>: 2025/8/9</p>
</li>
<li>
<p><strong>CPU:</strong> Intel Core i9-14900KF</p>
</li>
<li>
<p><strong>RAM:</strong> Crucial Pro 48GB DDR5-5600 x 4</p>
</li>
</ul>
</div>
<h3 id="gcc" class="discrete">GCC</h3>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=804955990&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=621295946&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=88715623&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=278187472&amp;format=interactive"></iframe>
</div>
</div>
<h3 id="clang" class="discrete">Clang</h3>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=679075429&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=1601224301&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=283810185&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=144195081&amp;format=interactive"></iframe>
</div>
</div>
<h3 id="msvc" class="discrete">MSVC</h3>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=1168105336&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=1271822110&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=873983110&amp;format=interactive"></iframe>
</div>
</div>
<div class="openblock benchmark">
<div class="content">
<iframe seamless frameborder="0" scrolling="no" src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQXYU9sO-RE4qKr80DUCgMye9GVX7uM6JjTRKbyXZo4U84nOiI0aOnrs1aynPsa5eSP8trZ8o_ivKdx/pubchart?oid=1452444822&amp;format=interactive"></iframe>
</div>
</div>
<h3 id="benchmark-analysis" class="discrete">Benchmark Analysis</h3>
<div class="paragraph">
<p>The graphs show that the cost of read-only access is remarkably small compared to the time spent on construction.</p>
</div>
<div class="paragraph">
<p>Read operations on a variant complete in constant time, as runtime dispatch is limited by the small, fixed number of alternatives. Benchmarks show <code>std::variant</code> and <code>rvariant</code> perform similarly, with read times unaffected by whether there are 3 or 16 alternatives and not scaling with <code>N</code>.</p>
</div>
<h4 id="visitation-technique-in-depth" class="discrete">Visitation Technique in Depth</h4>
<div class="paragraph">
<p>Some readers might assume that table-based visitation is the ideal approach, implying that visitations have <em>constant</em> time complexity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">using overload_type = R(*)(Visitor&amp;&amp;, Storage&amp;&amp;);
constexpr overload_type vtable[] = {
  &amp;do_visit&lt;0, Visitor, Storage&gt;,
  &amp;do_visit&lt;1, Visitor, Storage&gt;,
  &amp;do_visit&lt;2, Visitor, Storage&gt;,
  ...
};
vtable[v.index()](vis, v.storage()); // O(1), of course</code></pre>
</div>
</div>
<div class="paragraph">
<p>Early <code>std::variant</code> implementations used this <em>function-pointer-based dispatch</em>, but it was later found that this pattern results in poor inlining in major compilers, whereas <em>switch-case-based dispatch</em> is significantly better optimized (<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78113" target="_blank" rel="noopener">link</a>). GCC, LLVM, and MSVC subsequently adopted the latter approach.</p>
</div>
<div class="paragraph">
<p>Unfortunately, GCC enables the optimization only in limited scenarios (<a href="https://github.com/gcc-mirror/gcc/blob/679e24f5a751663998ff7202149a749e0f7251f9/libstdc%2B%2B-v3/include/std/variant#L1863" target="_blank" rel="noopener">link</a>), and LLVM has reverted it due to unresolved issues (<a href="https://github.com/llvm/llvm-project/issues/62648#issuecomment-1832315651" target="_blank" rel="noopener">link</a>). Our benchmark results reflect this status quo, with <code>rvariant</code> performing up to about 2x faster than GCC/Clang.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="about"><a class="anchor" href="#about"></a>About the Authors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Yaito Kakeyama is a C&#43;&#43; enthusiast with a strong interest in language design and modern library development. He has contributed to several public efforts in the C&#43;&#43; community, including co-authoring LWG 4166 with Nana Sakisaka and submitting occasional compiler bug reports. He is the co-author of <code>rvariant</code> and has been deeply involved in its implementation.</p>
</div>
<div class="paragraph">
<p>Nana Sakisaka has taken on an active maintainer role in Boost.Spirit since May 2025. The development of <code>rvariant</code> began as part of a broader effort to modernize the Boost.Spirit.X3 codebase. He is the co-author of <code>rvariant</code> and has focused on its rationale and specification wording.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="license"><a class="anchor" href="#license"></a>License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This library is distributed under the <a href="https://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>